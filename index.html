<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Topomapper</title>

  <!-- Libs -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <style>
    :root {
      /* Dark mode tokens */
      --color-bg: #141A22;
      --color-panel: rgba(28, 34, 44, 0.96);
      --color-primary: #4C8DFF;
      --color-primary-hover: #346FE0;
      --color-text: #F2F4F8;
      --color-text-sec: #A0A9B8;
      --color-border: rgba(255, 255, 255, 0.1);
      --radius-ios: 22px;
      --sidebar-w: 400px;
      --header-h: 72px;
      --blur: blur(40px);
    }

    * { box-sizing: border-box; outline: none; -webkit-tap-highlight-color: transparent; }

    body {
      margin: 0; font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto, sans-serif;
      background: var(--color-bg); color: var(--color-text); height: 100vh; overflow: hidden; display: flex;
    }

    /* HEADER */
    .top-header {
      position: fixed; top: 0; left: 0; right: 0; height: var(--header-h);
      display: flex; align-items: center; justify-content: space-between;
      padding: 0 28px; z-index: 1200;
      background: linear-gradient(180deg, rgba(8,11,16,0.95), rgba(8,11,16,0.55));
      border-bottom: 1px solid rgba(255,255,255,0.08); backdrop-filter: blur(12px);
    }
    .top-brand { display: flex; align-items: center; gap: 12px; font-weight: 800; font-size: 20px; letter-spacing: -0.6px; text-decoration: none; color: var(--color-text); }
    .top-logo { width: 34px; height: 34px; object-fit: contain; }
    .status-pill { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border-radius: 999px; font-size: 11px; font-weight: 600; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); color: var(--color-text-sec); }
    .status-pill.ok { color: #9BE2B7; border-color: rgba(155,226,183,0.4); background: rgba(155,226,183,0.12); }
    .status-pill.error { color: #FF9A9A; border-color: rgba(255,154,154,0.4); background: rgba(255,154,154,0.12); }

    /* MAP AREA */
    .viewport { position: relative; flex: 1; height: 100%; }
    #map { width: 100%; height: 100%; z-index: 0; background: #10141B; filter: contrast(1.1) saturate(0.85) brightness(0.92) hue-rotate(210deg); transition: filter 0.3s ease; }

    /* SIDEBAR (iOS Floating Panel) */
    .sidebar {
      position: absolute; top: calc(var(--header-h) + 12px); left: 16px; bottom: 16px; width: var(--sidebar-w);
      z-index: 1000; background: var(--color-panel); backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur); border: 1px solid rgba(255,255,255,0.08);
      border-radius: var(--radius-ios); box-shadow: 0 20px 55px rgba(0,0,0,0.45);
      display: flex; flex-direction: column; overflow: hidden;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .sidebar:hover { transform: translateY(-2px); box-shadow: 0 26px 65px rgba(0,0,0,0.5); }

    .sidebar-header {
      padding: 24px; border-bottom: 1px solid var(--color-border);
      display: flex; align-items: center; justify-content: space-between;
      background: rgba(16, 20, 28, 0.8);
    }
    .brand { font-weight: 800; font-size: 24px; letter-spacing: -0.8px; color: var(--color-text); text-decoration: none; display: flex; align-items: center; gap: 10px; }
    .scroll-content { flex: 1; overflow-y: auto; padding: 24px; }

    /* UI GROUPS */
    .group { margin-bottom: 28px; }
    label { font-size: 11px; font-weight: 700; color: var(--color-text-sec); margin-bottom: 8px; display: block; text-transform: uppercase; letter-spacing: 0.5px; }

    input, select {
      width: 100%; padding: 12px 14px; border-radius: 12px;
      border: 1px solid transparent; background: rgba(118, 118, 128, 0.28);
      font-size: 15px; color: var(--color-text); transition: 0.2s; box-shadow: inset 0 0 0 1px rgba(255,255,255,0.04);
    }
    select option { background: #0f141c; color: var(--color-text); }
    input:focus, select:focus { background: rgba(255,255,255,0.12); border-color: var(--color-primary); box-shadow: 0 0 0 3px rgba(76,141,255,0.25); }
    input:hover, select:hover { border-color: rgba(255,255,255,0.18); }
    .input-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }

    /* SEARCH */
    .search-container { position: relative; }
    .suggestions {
      position: absolute; top: 100%; left: 0; right: 0; background: rgba(18,22,30,0.98);
      backdrop-filter: blur(15px); border-radius: 14px; margin-top: 8px; padding: 6px; z-index: 2000;
      box-shadow: 0 10px 40px rgba(0,0,0,0.45); border: 1px solid var(--color-border); display: none;
    }
    .suggestion-item { padding: 12px; font-size: 14px; border-radius: 10px; cursor: pointer; border-bottom: 1px solid rgba(255,255,255,0.06); }
    .suggestion-item:hover { background: rgba(255,255,255,0.06); color: var(--color-primary); }

    /* LAYER LIST & CUSTOMIZER */
    .layer-list { display: flex; flex-direction: column; gap: 8px; }
    .layer-item {
      background: rgba(255,255,255,0.09); border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.16); transition: 0.2s; overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.35);
    }
    .layer-item:hover { border-color: rgba(255,255,255,0.28); transform: translateY(-1px); }
    .layer-item.open { background: rgba(255,255,255,0.14); border-color: rgba(76,141,255,0.6); }
    .layer-head { display: flex; align-items: center; justify-content: space-between; padding: 14px 18px; cursor: pointer; }
    .layer-actions { display: inline-flex; align-items: center; gap: 10px; }
    .layer-info { display: flex; align-items: center; gap: 10px; font-weight: 600; font-size: 15px; }
    .chevron { transition: transform 0.3s; width: 14px; height: 14px; opacity: 0.4; }
    .layer-item.open .chevron { transform: rotate(180deg); opacity: 1; color: var(--color-primary); }
    .layer-body { display: none; padding: 0 18px 18px 18px; background: rgba(10,12,18,0.7); }
    .layer-item.open .layer-body { display: block; }
    .layer-item.dragging { opacity: 0.65; border-color: rgba(76,141,255,0.8); }
    .drag-handle { display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; margin-right: 6px; opacity: 0.5; cursor: grab; }
    .drag-handle svg { width: 16px; height: 16px; }
    .layer-head { cursor: pointer; }
    .layer-head.drag-ready { cursor: grab; }

    .stepper {
      display: flex;
      gap: 8px;
      background: rgba(255,255,255,0.06);
      padding: 6px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.08);
    }
    .stepper button {
      border: none;
      background: transparent;
      color: var(--color-text-sec);
      font-weight: 700;
      font-size: 12px;
      padding: 8px 14px;
      border-radius: 999px;
      cursor: pointer;
      transition: 0.2s ease;
    }
    .stepper button.active {
      background: rgba(76,141,255,0.18);
      color: var(--color-primary);
      border: 1px solid rgba(76,141,255,0.35);
    }
    .step-content { display: none; }
    .step-content.active { display: block; }

    /* CUSTOMIZER CONTROLS */
    .cust-row { display: flex; align-items: center; justify-content: space-between; margin-top: 12px; gap: 10px; }
    .color-dot { width: 32px; height: 32px; border-radius: 50%; border: 3px solid rgba(15,18,25,0.9); box-shadow: 0 2px 10px rgba(0,0,0,0.35); position: relative; overflow: hidden; cursor: pointer; }
    .color-dot input { position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; opacity: 0; cursor: pointer; }
    input[type=range] { flex: 1; height: 4px; border-radius: 2px; background: rgba(255,255,255,0.16); -webkit-appearance: none; }
    input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #F5F7FB; box-shadow: 0 2px 8px rgba(0,0,0,0.35); border: 0.5px solid rgba(0,0,0,0.3); }

    /* IOS SWITCH */
    .ios-switch {
      position: relative; width: 44px; height: 26px;
      background: rgba(255,255,255,0.18); border-radius: 20px; cursor: pointer; transition: 0.3s;
    }
    .ios-switch::after {
      content: ''; position: absolute; top: 2px; left: 2px;
      width: 22px; height: 22px; background: #F5F7FB; border-radius: 50%;
      box-shadow: 0 2px 6px rgba(0,0,0,0.45); transition: 0.3s cubic-bezier(0.3, 1.5, 0.7, 1);
    }
    .ios-switch.on { background: #34C759; }
    .ios-switch.on::after { transform: translateX(18px); }

    /* BUTTONS */
    .btn-main {
      width: 100%; padding: 18px; border-radius: 16px; border: none;
      font-weight: 700; font-size: 17px; cursor: pointer; transition: 0.2s;
      background: var(--color-primary); color: #fff; box-shadow: 0 12px 24px rgba(76,141,255,0.25);
    }
    .btn-main:hover { transform: translateY(-2px); background: var(--color-primary-hover); }
    .btn-main:active { transform: translateY(0); }
    .btn-secondary {
      width: 100%;
      padding: 14px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      color: var(--color-text);
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: 0.2s ease;
      box-shadow: none;
    }
    .btn-secondary:hover:not(:disabled) { background: rgba(255,255,255,0.12); }
    .btn-secondary:disabled { cursor: not-allowed; opacity: 0.45; }

    .info-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 11px;
      font-weight: 600;
      color: var(--color-text-sec);
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
    }
    .gradient-preview {
      height: 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: linear-gradient(90deg, #0B1B2C, #7CA6C7);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.35);
      margin-top: 8px;
    }
    .toggle-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    /* VIEWFINDER Overlay */
    .viewfinder-wrapper { position: absolute; inset: 0; pointer-events: none; z-index: 500; }
    .vf-mask { fill: rgba(0,0,0,0.35); }
    .vf-stroke { fill: none; stroke: #fff; stroke-width: 2.5; filter: drop-shadow(0 0 7px rgba(0,0,0,0.6)); }
    .vf-badge {
      position: absolute;
      transform: translate(-50%, -50%); /* Centered on the bottom line */
      background: var(--color-primary);
      color: #fff; padding: 8px 16px;
      border-radius: 20px; font-size: 12px; font-weight: 700; white-space: nowrap;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      pointer-events: auto;
    }

    /* MODAL SHEETS */
    .modal-overlay {
      position: fixed; inset: 0; background: rgba(5,8,12,0.65); backdrop-filter: blur(10px);
      z-index: 2000; display: none; align-items: center; justify-content: center; opacity: 0; transition: 0.3s;
    }
    .modal-overlay.open { display: flex; opacity: 1; }
    .modal-card {
      width: 95vw; height: 92vh; background: #0F141C; border-radius: 32px;
      display: flex; overflow: hidden; box-shadow: 0 40px 120px rgba(0,0,0,0.6);
    }
    .preview-stage {
      flex: 1; background: #0B0F14; display: flex; align-items: stretch; justify-content: stretch;
      padding: clamp(16px, 2vw, 40px); overflow: hidden;
    }
    #previewArea { flex: 1; display: flex; align-items: center; justify-content: center; }
    #previewArea svg { width: 100%; height: 100%; max-width: 100%; max-height: 100%; }
    .export-side { width: 400px; background: #121821; border-left: 1px solid var(--color-border); padding: 40px; display: flex; flex-direction: column; gap: 30px; overflow-y: auto; }

    /* LOADER */
    .loader {
      position: fixed; top: 30px; left: 50%; transform: translateX(-50%);
      background: #121821; padding: 14px 28px; border-radius: 40px; z-index: 9999; display: none; align-items: center; gap: 12px;
      font-weight: 600; box-shadow: 0 10px 30px rgba(0,0,0,0.45); border: 1px solid var(--color-border);
    }
    .loader.active { display: flex; }
    .spinner { width: 20px; height: 20px; border: 3px solid rgba(255,255,255,0.2); border-top-color: var(--color-primary); border-radius: 50%; animation: spin 0.8s infinite linear; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>

<div id="loader" class="loader"><div class="spinner"></div><span id="loaderText">Loading...</span></div>

<header class="top-header">
  <a class="top-brand" href="#">
    <img class="top-logo" src="assets/logo.png" alt="Topomapper logo">
    Topomapper
  </a>
</header>

<div class="sidebar">
  <div class="sidebar-header">
    <a href="#" class="brand">
      <svg width="26" height="26" viewBox="0 0 48 48" fill="none" aria-hidden="true">
        <rect x="6" y="6" width="36" height="36" rx="12" fill="rgba(76,141,255,0.18)" stroke="rgba(76,141,255,0.6)" stroke-width="1.5"/>
        <path d="M12 18c4-6 20-8 24-2" stroke="var(--color-primary)" stroke-width="2.2" fill="none"/>
        <path d="M12 24c5-5 19-6 24-1" stroke="rgba(76,141,255,0.75)" stroke-width="2" fill="none"/>
        <path d="M12 30c6-4 18-4 24 1" stroke="rgba(76,141,255,0.55)" stroke-width="1.8" fill="none"/>
        <path d="M16 36c4-2 12-2 16 1" stroke="rgba(76,141,255,0.4)" stroke-width="1.6" fill="none"/>
      </svg>
      Topomapper
    </a>
  </div>
  <div class="scroll-content">
    <div class="group">
      <label>Location Search</label>
      <div class="search-container">
        <input type="text" id="searchInp" placeholder="City, Region..." autocomplete="off">
        <div id="suggestionBox" class="suggestions"></div>
      </div>
    </div>

    <div class="group">
      <label>Format & Dimension</label>
      <select id="shapeSel" style="margin-bottom:12px;">
        <option value="rect">Rectangle</option>
        <option value="din_l">DIN Landscape</option>
        <option value="din_p">DIN Portrait</option>
        <option value="sq">Square</option>
        <option value="circle">Circle</option>
        <option value="hex">Hexagon</option>
      </select>
      <div class="input-grid">
        <div><label>Width (mm)</label><input type="number" id="dimW" value="200"></div>
        <div><label>Height (mm)</label><input type="number" id="dimH" value="140"></div>
      </div>
    </div>

    <div class="group">
      <label>Step 1 路 Choose Frame</label>
      <p style="font-size:12px; color:var(--color-text-sec); margin-top:6px; line-height:1.4;">
        Contour styling, color presets, and map feature layers are adjusted in the preview panel after generation.
      </p>
    </div>

    <button id="btnGen" class="btn-main">Generate Preview</button>
  </div>
</div>

<div class="viewport">
  <div id="map"></div>
  <div class="viewfinder-wrapper">
    <svg id="vfSvg" width="100%" height="100%">
      <defs><mask id="vfMask"><rect width="100%" height="100%" fill="white"/><path id="vfHole" fill="black"/></mask></defs>
      <rect width="100%" height="100%" class="vf-mask" mask="url(#vfMask)"/>
      <path id="vfOutline" class="vf-stroke" />
    </svg>
    <div id="vfBadge" class="vf-badge">200 x 140 mm</div>
  </div>
</div>

<div class="modal-overlay" id="modal">
  <div class="modal-card">
    <div class="preview-stage" id="previewArea"></div>
    <div class="export-side">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div>
          <h2 style="margin:0; font-size:24px; font-weight:800; letter-spacing:-1px;">Preview & Export</h2>
          <div style="font-size:12px; color:var(--color-text-sec); margin-top:4px;">Step 2: Choose Design 路 Step 3: Export Design</div>
        </div>
        <button onclick="closeModal()" style="border:none;background:none;font-size:32px;cursor:pointer;color:var(--color-text-sec);">&times;</button>
      </div>

      <div class="stepper">
        <button class="active" data-step-target="2">Step 2 路 Choose Design</button>
        <button data-step-target="3">Step 3 路 Export Design</button>
      </div>

      <div class="step-content active" data-step="2">
        <div class="group">
          <label>Preview</label>
          <p style="font-size:12px; color:var(--color-text-sec); margin-top:6px; line-height:1.4;">
            The preview updates only when you refresh.
          </p>
          <button id="refreshPreview" class="btn-secondary" disabled>Refresh Preview</button>
        </div>
        <div class="group">
          <label>Design Preset</label>
          <select id="presetSel" style="margin-top:6px;">
            <option value="dark">Dark (Negative)</option>
            <option value="bright">Bright (Positive)</option>
            <option value="grayscale">Greyscale (Mono)</option>
          </select>
          <div id="designColors" style="margin-top:12px;">
            <div class="cust-row">
              <label style="margin:0">Background</label>
              <div class="color-dot" id="bgColorDot" style="background:#141A22"><input type="color" id="bgColorPicker" value="#141A22"></div>
              <input type="text" id="bgColorText" placeholder="#141A22 or rgb(20,26,34)" style="flex:1">
            </div>
            <div class="cust-row">
              <label style="margin:0">Contour Lines</label>
              <div class="color-dot" id="lineColorDot" style="background:#D7E3FF"><input type="color" id="lineColorPicker" value="#D7E3FF"></div>
              <input type="text" id="lineColorText" placeholder="#D7E3FF or rgb(215,227,255)" style="flex:1">
            </div>
          </div>
        </div>

        <div class="group">
          <label>Layer Stack (Drag to Reorder)</label>
          <p style="font-size:12px; color:var(--color-text-sec); margin-top:6px; line-height:1.4;">
            Grab the handle to move layers. Items higher in the list render above the ones below.
          </p>
          <div id="mapDataStatus" class="status-pill" style="margin-top:10px;">Map data: --</div>
          <div id="layerStack" class="layer-list">
            <div class="layer-item" data-layer="labels" draggable="true">
              <div class="layer-head drag-ready">
                <div class="layer-info">
                  <span class="drag-handle" title="Drag to reorder">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 6h8M8 12h8M8 18h8"/></svg>
                  </span>
                  <svg class="chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M6 9l6 6 6-6"/></svg>
                  <span>Place Names</span>
                </div>
                <div class="layer-actions">
                  <div class="ios-switch" id="labelToggle"></div>
                </div>
              </div>
              <div class="layer-body">
                <div class="cust-row"><label style="margin:0">Label Color</label><div class="color-dot" id="labelColorDot" style="background:#1E232B"><input type="color" id="labelColor" value="#1E232B"></div></div>
                <div class="cust-row"><label style="margin:0">Opacity</label><input type="range" id="labelOpacity" min="0" max="100" step="1" value="85"><span id="labelOpacityVal" style="font-size:11px;width:36px;text-align:right;">85%</span></div>
                <div class="cust-row"><label style="margin:0">Font Size</label><input type="range" id="labelSize" min="0.2" max="1.5" step="0.1" value="0.32"><span id="labelSizeVal" style="font-size:11px;width:36px;text-align:right;">0.32</span></div>
                <div class="cust-row"><label style="margin:0">Typeface</label>
                  <select id="labelFont">
                    <option value="system" selected>System Sans</option>
                    <option value="serif">Serif</option>
                    <option value="mono">Mono</option>
                  </select>
                </div>
              </div>
            </div>
            <div class="layer-item" data-layer="roads" draggable="true" style="margin-top:10px;">
              <div class="layer-head drag-ready">
                <div class="layer-info">
                  <span class="drag-handle" title="Drag to reorder">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 6h8M8 12h8M8 18h8"/></svg>
                  </span>
                  <svg class="chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M6 9l6 6 6-6"/></svg>
                  <span>Roads</span>
                </div>
                <div class="layer-actions">
                  <div class="ios-switch" id="roadToggle"></div>
                </div>
              </div>
              <div class="layer-body">
                <div class="cust-row"><label style="margin:0">Color</label><div class="color-dot" id="roadColorDot" style="background:#C9A75A"><input type="color" id="roadColor" value="#C9A75A"></div></div>
                <div class="cust-row"><label style="margin:0">Line Width</label><input type="range" id="roadWidth" min="0.05" max="0.6" step="0.05" value="0.35"><span id="roadWidthVal" style="font-size:11px;width:36px;text-align:right;">0.35</span></div>
                <div class="cust-row"><label style="margin:0">Opacity</label><input type="range" id="roadOpacity" min="0" max="100" step="1" value="75"><span id="roadOpacityVal" style="font-size:11px;width:36px;text-align:right;">75%</span></div>
              </div>
            </div>
            <div class="layer-item" data-layer="rivers" draggable="true" style="margin-top:10px;">
              <div class="layer-head drag-ready">
                <div class="layer-info">
                  <span class="drag-handle" title="Drag to reorder">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 6h8M8 12h8M8 18h8"/></svg>
                  </span>
                  <svg class="chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M6 9l6 6 6-6"/></svg>
                  <span>Rivers</span>
                </div>
                <div class="layer-actions">
                  <div class="ios-switch on" id="riverToggle"></div>
                </div>
              </div>
              <div class="layer-body">
                <div class="cust-row"><label style="margin:0">Line Color</label><div class="color-dot" id="riverColorDot" style="background:#7DB5D3"><input type="color" id="riverColor" value="#7DB5D3"></div></div>
                <div class="cust-row"><label style="margin:0">Line Width</label><input type="range" id="riverWidth" min="0.05" max="0.6" step="0.05" value="0.4"><span id="riverWidthVal" style="font-size:11px;width:36px;text-align:right;">0.4</span></div>
                <div class="cust-row"><label style="margin:0">Opacity</label><input type="range" id="riverOpacity" min="0" max="100" step="1" value="85"><span id="riverOpacityVal" style="font-size:11px;width:36px;text-align:right;">85%</span></div>
              </div>
            </div>
            <div class="layer-item" data-layer="water" draggable="true" style="margin-top:10px;">
              <div class="layer-head drag-ready">
                <div class="layer-info">
                  <span class="drag-handle" title="Drag to reorder">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 6h8M8 12h8M8 18h8"/></svg>
                  </span>
                  <svg class="chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M6 9l6 6 6-6"/></svg>
                  <span>Water Areas</span>
                </div>
                <div class="layer-actions">
                  <div class="ios-switch on" id="waterAreaToggle"></div>
                </div>
              </div>
              <div class="layer-body">
                <div class="cust-row"><label style="margin:0">Fill</label><div class="color-dot" id="waterAreaColorDot" style="background:#7DB5D3"><input type="color" id="waterAreaColor" value="#7DB5D3"></div></div>
                <div class="cust-row"><label style="margin:0">Opacity</label><input type="range" id="waterAreaOpacity" min="0" max="100" step="1" value="45"><span id="waterAreaOpacityVal" style="font-size:11px;width:36px;text-align:right;">45%</span></div>
              </div>
            </div>
            <div class="layer-item" data-layer="green" draggable="true" style="margin-top:10px;">
              <div class="layer-head drag-ready">
                <div class="layer-info">
                  <span class="drag-handle" title="Drag to reorder">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 6h8M8 12h8M8 18h8"/></svg>
                  </span>
                  <svg class="chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M6 9l6 6 6-6"/></svg>
                  <span>Green Areas</span>
                </div>
                <div class="layer-actions">
                  <div class="ios-switch on" id="greenAreaToggle"></div>
                </div>
              </div>
              <div class="layer-body">
                <div class="cust-row"><label style="margin:0">Fill</label><div class="color-dot" id="greenAreaColorDot" style="background:#7FAE8A"><input type="color" id="greenAreaColor" value="#7FAE8A"></div></div>
                <div class="cust-row"><label style="margin:0">Opacity</label><input type="range" id="greenAreaOpacity" min="0" max="100" step="1" value="15"><span id="greenAreaOpacityVal" style="font-size:11px;width:36px;text-align:right;">15%</span></div>
              </div>
            </div>
            <div class="layer-item open" data-layer="contours" draggable="true" style="margin-top:10px;">
              <div class="layer-head drag-ready">
                <div class="layer-info">
                  <span class="drag-handle" title="Drag to reorder">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 6h8M8 12h8M8 18h8"/></svg>
                  </span>
                  <svg class="chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M6 9l6 6 6-6"/></svg>
                  <span>Contour Lines</span>
                </div>
                <div class="layer-actions">
                  <div class="ios-switch on" id="contourToggle"></div>
                </div>
              </div>
              <div class="layer-body">
                <div class="cust-row"><label style="margin:0">Color</label><div class="color-dot" style="background:#10141B"><input type="color" id="contourColor" value="#10141B"></div></div>
                <div class="cust-row"><label style="margin:0">Line Width</label><input type="range" id="contourWidth" min="0.05" max="0.6" step="0.05" value="0.2"><span id="contourWidthVal" style="font-size:11px;width:36px;text-align:right;">0.2</span></div>
                <div class="cust-row"><label style="margin:0">Density</label><input type="range" id="contourDensity" min="8" max="60" step="2" value="24"><span id="contourDensityVal" style="font-size:11px;width:36px;text-align:right;">24</span></div>
          <div class="cust-row"><label style="margin:0">Opacity</label><input type="range" id="contourOpacity" min="0" max="100" step="1" value="80"><span id="contourOpacityVal" style="font-size:11px;width:36px;text-align:right;">80%</span></div>
                <div class="cust-row"><label style="margin:0">Smoothing</label><input type="range" id="contourSmooth" min="0" max="4" step="1" value="1"><span id="contourSmoothVal" style="font-size:11px;width:36px;text-align:right;">1</span></div>
              </div>
            </div>
          </div>
        </div>
        <div class="group">
          <label>Hypsometric Fill (PNG)</label>
          <div class="layer-item" style="padding: 12px 14px; display:flex; flex-direction:column; gap:10px;">
            <div class="toggle-row">
              <span style="font-weight:600; font-size:14px;">Layered Height Bands</span>
              <div class="ios-switch" id="pngLayerToggle"></div>
            </div>
            <p style="font-size:11px; color:var(--color-text-sec); margin:0; line-height:1.4;">
              Fills each contour band with stepped colors and hillshade based on the lowest/highest points in the frame.
            </p>
            <div id="pngLayerOptions" style="display:none;">
              <div class="cust-row">
                <label style="margin:0">Color Scheme</label>
                <select id="pngScheme">
                  <option value="color" selected>Topographic Color</option>
                  <option value="mono">Topographic Mono</option>
                </select>
              </div>
              <div class="cust-row">
                <label style="margin:0">Fill Opacity</label>
                <input type="range" id="pngGradOpacity" min="0" max="100" step="1" value="90">
                <span id="pngGradOpacityVal" style="font-size:11px;width:36px;text-align:right;">90%</span>
              </div>
              <div class="cust-row">
                <label style="margin:0">Gradient Shift</label>
                <input type="range" id="pngGradShift" min="-50" max="50" step="1" value="0">
                <span id="pngGradShiftVal" style="font-size:11px;width:44px;text-align:right;">0%</span>
              </div>
              <div class="cust-row">
                <label style="margin:0">Gradient Scale</label>
                <input type="range" id="pngGradScale" min="50" max="150" step="1" value="100">
                <span id="pngGradScaleVal" style="font-size:11px;width:44px;text-align:right;">100%</span>
              </div>
              <div class="gradient-preview" id="pngGradientPreview"></div>
              <div class="info-pill" id="pngRangeInfo" style="margin-top:10px;">Range: --</div>
            </div>
          </div>
        </div>
        <button id="toExport" class="btn-main" style="margin-top:6px;">Continue to Export Design</button>
      </div>

      <div class="step-content" data-step="3">
        <button id="backToStyle" class="btn-main" style="background:#3A3A3C;">Back to Design</button>
        <div class="group" style="margin-top:20px;">
        <label>3D Print (3MF Terrain)</label>
        <p style="font-size:13px; color:var(--color-text-sec); margin-bottom:12px; line-height:1.5;">
          Creates a watertight relief mesh based on elevation data. Contours remain 2D for vector exports.
        </p>
        <div class="input-grid">
           <div><label>Socket (mm)</label><input type="text" value="2.0" disabled></div>
           <div><label>Relief Hub</label><input type="number" id="targetH" value="10"></div>
        </div>
        <button id="btn3MF" class="btn-main" style="margin-top:10px;">Download 3MF</button>
      </div>

      <div class="group">
        <label>Laser / Vector (DXF)</label>
        <button id="btnDXF" class="btn-main" style="background:#3A3A3C;">Download DXF</button>
      </div>

      <div class="group">
        <label>Poster (PNG High-Res)</label>
        <label style="margin-top:10px; font-size:10px;">Resolution (Long Edge)</label>
        <div class="cust-row" style="margin-bottom:8px;">
          <input type="range" id="pngResRange" min="500" max="5000" step="100" value="2000">
          <span id="pngResVal" style="font-size:12px; font-weight:700; width:60px;">2000px</span>
        </div>
        <button id="btnPNG" class="btn-main" style="background:#2B3440; color:#F5F7FB;">Save PNG</button>
      </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // --- STATE ---
  const state = {
    wMm: 200, hMm: 140, shape: 'rect',
    contour: {
      enabled: true,
      density: 24,
      width: 0.2,
      color: '#10141B',
      smooth: 1,
      opacity: 80
    },
    png: {
      layered: false,
      scheme: 'color',
      gradientOpacity: 90,
      gradientShift: 0,
      gradientScale: 100,
      reliefStrength: 0.48,
      reliefWarm: '#F3A15F',
      reliefShadow: '#0A1624'
    },
    theme: {
      preset: 'bright',
      background: '#F5F2EB',
      line: '#10141B'
    },
    mapFeatures: {
      waterAreas: { enabled: true, color: '#7DB5D3', opacity: 45 },
      rivers: { enabled: true, color: '#7DB5D3', width: 0.4, opacity: 85 },
      greenAreas: { enabled: true, color: '#7FAE8A', opacity: 15 },
      roads: { enabled: false, color: '#C9A75A', width: 0.35, opacity: 75 },
      labels: { enabled: false, color: '#1E232B', size: 0.32, font: 'system', opacity: 85 }
    },
    layerOrder: ['labels', 'roads', 'rivers', 'water', 'green', 'contours'],
    bbox: null,
    terrainData: null,
    contourPaths: [],
    osmData: null,
    osmStatus: { loaded: false, error: null, tiles: 1, ignored: false },
    previewDirty: false
  };

  const $ = id => document.getElementById(id);
  const msg = t => { $('loaderText').innerText=t; $('loader').classList.add('active'); };
  const idle = () => $('loader').classList.remove('active');
  const refreshPreviewBtn = $('refreshPreview');

  // --- HELPERS: SCALING & INTERPOLATION ---
  function getZInterpolated(nx, ny) {
    if(!state.terrainData) return 0;
    const T = state.terrainData;
    const rFloat = ny * (T.rows-1);
    const cFloat = nx * (T.cols-1);
    const r0 = Math.floor(rFloat), r1 = Math.min(T.rows-1, r0+1);
    const c0 = Math.floor(cFloat), c1 = Math.min(T.cols-1, c0+1);
    const dr = rFloat - r0, dc = cFloat - c0;
    const h00 = T.h[r0*T.cols+c0], h01 = T.h[r0*T.cols+c1], h10 = T.h[r1*T.cols+c0], h11 = T.h[r1*T.cols+c1];
    return (h00*(1-dr)*(1-dc) + h01*(1-dr)*dc + h10*dr*(1-dc) + h11*dr*dc);
  }

  function isInShape(x, y) {
    if(['rect','din_l','din_p','sq'].includes(state.shape)) return true;
    const dx = x - state.wMm / 2;
    const dy = y - state.hMm / 2;
    if(state.shape === 'circle') return (dx*dx + dy*dy) <= (state.wMm/2) ** 2;
    if(state.shape !== 'hex') return true;
    const qx = Math.abs(dx) / (state.wMm / 2);
    const qy = Math.abs(dy) / (state.hMm / 2);
    return qx + qy * 0.577 <= 1;
  }

  function getContourLineCount() {
    const desired = Math.max(4, Math.round(state.contour.density));
    const minSpacing = Math.max(1.2, state.contour.width * 8);
    const maxLines = Math.max(4, Math.floor(Math.min(state.wMm, state.hMm) / minSpacing));
    return Math.max(4, Math.min(desired, maxLines));
  }

  function getContourLevels(minNorm = 0, maxNorm = state.terrainData?.delta ?? 0) {
    if(!state.terrainData || maxNorm <= minNorm) return [];
    const lineCount = getContourLineCount();
    const interval = (maxNorm - minNorm) / lineCount;
    return Array.from({length: lineCount - 1}, (_, i) => minNorm + interval * (i + 1));
  }

  function getShapeHeightRange() {
    if(!state.terrainData) return null;
    const { rows, cols, h, min, delta } = state.terrainData;
    let minZ = Infinity;
    let maxZ = -Infinity;
    for(let r=0; r<rows; r++) {
      const y = (r / (rows - 1)) * state.hMm;
      for(let c=0; c<cols; c++) {
        const x = (c / (cols - 1)) * state.wMm;
        if(!isInShape(x, y)) continue;
        const z = min + h[r * cols + c];
        if(z < minZ) minZ = z;
        if(z > maxZ) maxZ = z;
      }
    }
    if(!Number.isFinite(minZ) || !Number.isFinite(maxZ)) {
      minZ = min;
      maxZ = min + delta;
    }
    return { minZ, maxZ, minNorm: minZ - min, maxNorm: maxZ - min };
  }

  function parseHexColor(hex) {
    const v = hex.replace('#', '').trim();
    if(v.length === 3) {
      return {
        r: parseInt(v[0] + v[0], 16),
        g: parseInt(v[1] + v[1], 16),
        b: parseInt(v[2] + v[2], 16)
      };
    }
    if(v.length === 6) {
      return {
        r: parseInt(v.slice(0,2), 16),
        g: parseInt(v.slice(2,4), 16),
        b: parseInt(v.slice(4,6), 16)
      };
    }
    return { r: 0, g: 0, b: 0 };
  }

  function colorToRgb(color) {
    const tester = new Option().style;
    tester.color = color;
    const parsed = tester.color || '#000000';
    if(parsed.startsWith('#')) {
      return parseHexColor(parsed);
    }
    const match = parsed.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
    if(match) {
      return { r: parseInt(match[1], 10), g: parseInt(match[2], 10), b: parseInt(match[3], 10) };
    }
    return { r: 0, g: 0, b: 0 };
  }

  function lerp(a, b, t) { return a + (b - a) * t; }
  function clamp(val, min, max) { return Math.min(max, Math.max(min, val)); }

  function gradientColor(startColor, endColor, t) {
    const s = colorToRgb(startColor);
    const e = colorToRgb(endColor);
    const tt = clamp(t, 0, 1);
    return {
      r: Math.round(lerp(s.r, e.r, tt)),
      g: Math.round(lerp(s.g, e.g, tt)),
      b: Math.round(lerp(s.b, e.b, tt))
    };
  }

  const getHypsometricStops = (scheme) => {
    if(scheme === 'mono') {
      return ['#FFFFFF', '#E6E6E6', '#CCCCCC', '#B3B3B3', '#999999', '#7F7F7F', '#666666', '#4D4D4D', '#333333'];
    }
    const stops = [
      '#0F3E63',
      '#1F5C83',
      '#3B7EA6',
      '#6AA1C2',
      '#9EC3D9',
      '#BFD9B3',
      '#9FBE7E',
      '#CBB878',
      '#B18D5B',
      '#8E6C45'
    ];
    const waterColor = state.mapFeatures?.waterAreas?.color;
    const greenColor = state.mapFeatures?.greenAreas?.color;
    if(waterColor && greenColor) {
      stops[0] = waterColor;
      stops[1] = gradientColor(waterColor, greenColor, 0.55);
      stops[2] = greenColor;
    } else if(waterColor) {
      stops[0] = waterColor;
      stops[1] = gradientColor(waterColor, stops[2], 0.5);
    } else if(greenColor) {
      stops[0] = gradientColor(greenColor, stops[0], 0.6);
      stops[1] = greenColor;
    }
    return stops;
  };

  const getScaledGradientT = (t) => {
    const scale = Math.max(0.5, Math.min(1.5, (state.png.gradientScale ?? 100) / 100));
    const shift = Math.max(-0.5, Math.min(0.5, (state.png.gradientShift ?? 0) / 100));
    return clamp((t - 0.5) / scale + 0.5 + shift, 0, 1);
  };

  const getHypsometricBandColor = (t, scheme, bandCount) => {
    const clamped = getScaledGradientT(t);
    const bandIndex = Math.min(bandCount - 1, Math.floor(clamped * bandCount));
    const stops = getHypsometricStops(scheme);
    if(bandCount <= 1) return colorToRgb(stops[0]);
    const scaled = bandIndex / (bandCount - 1);
    const stopIndex = scaled * (stops.length - 1);
    const low = Math.floor(stopIndex);
    const high = Math.min(stops.length - 1, low + 1);
    const mixT = stopIndex - low;
    const base = gradientColor(stops[low], stops[high], mixT);
    return base;
  };

  function mixColor(base, overlay, t) {
    const tt = clamp(t, 0, 1);
    return {
      r: Math.round(lerp(base.r, overlay.r, tt)),
      g: Math.round(lerp(base.g, overlay.g, tt)),
      b: Math.round(lerp(base.b, overlay.b, tt))
    };
  }

  const reliefLight = (() => {
    const v = { x: -0.62, y: -0.48, z: 0.6 };
    const len = Math.hypot(v.x, v.y, v.z) || 1;
    return { x: v.x / len, y: v.y / len, z: v.z / len };
  })();

  function getHillshade(nx, ny, step, centerZ) {
    if(!state.terrainData) return 0.5;
    const safeStep = Math.max(1e-6, step);
    const z0 = centerZ ?? getZInterpolated(nx, ny);
    const zRight = getZInterpolated(Math.min(1, nx + safeStep), ny);
    const zDown = getZInterpolated(nx, Math.min(1, ny + safeStep));
    const dzdx = (zRight - z0) / safeStep;
    const dzdy = (zDown - z0) / safeStep;
    const relief = clamp(state.terrainData.delta / 700, 0.35, 1.25);
    const nxv = -dzdx * relief;
    const nyv = -dzdy * relief;
    const nzv = 1;
    const len = Math.hypot(nxv, nyv, nzv) || 1;
    const dot = (nxv / len) * reliefLight.x + (nyv / len) * reliefLight.y + (nzv / len) * reliefLight.z;
    const ambient = 0.36;
    const lit = Math.max(0, dot);
    return clamp(ambient + lit * (1 - ambient), 0, 1);
  }

  function applyReliefOverlay(baseColor, shade, elevationT) {
    const strength = clamp(state.png.reliefStrength ?? 0.45, 0, 1);
    if(strength <= 0) return baseColor;
    const warm = colorToRgb(state.png.reliefWarm);
    const shadow = colorToRgb(state.png.reliefShadow);
    const highlight = clamp((shade - 0.5) * 2, 0, 1) * strength;
    const shadowMix = clamp((0.5 - shade) * 2, 0, 1) * strength;
    const peakBoost = clamp((elevationT - 0.6) / 0.4, 0, 1) * (strength * 0.45);
    let color = mixColor(baseColor, warm, clamp(highlight + peakBoost, 0, 1));
    color = mixColor(color, shadow, shadowMix);
    return color;
  }

  function getLayeredPreviewDataUrl() {
    if(!state.terrainData) return null;
    const alpha = Math.round(255 * clamp(toUnitOpacity(state.png.gradientOpacity), 0, 1));
    const ratio = state.hMm / state.wMm;
    const target = 320;
    let w = target;
    let h = Math.max(1, Math.round(target * ratio));
    if(h > target) {
      h = target;
      w = Math.max(1, Math.round(target / ratio));
    }
    const range = getShapeHeightRange();
    if(!range) return null;
    const boundaries = [range.minNorm, ...getContourLevels(range.minNorm, range.maxNorm), range.maxNorm];
    if(boundaries.length < 2) return null;
    const bandCount = Math.max(2, boundaries.length - 1);
    const bandColors = [];
    for(let i=0; i<boundaries.length - 1; i++) {
      const midNorm = (boundaries[i] + boundaries[i + 1]) / 2;
      const height = state.terrainData.min + midNorm;
      const t = range.maxZ === range.minZ ? 0 : (height - range.minZ) / (range.maxZ - range.minZ);
      bandColors.push(getHypsometricBandColor(t, state.png.scheme, bandCount));
    }
    const cv = document.createElement('canvas');
    cv.width = w;
    cv.height = h;
    const ctx = cv.getContext('2d');
    const imgData = ctx.createImageData(w, h);
    const data = imgData.data;
    const step = 1 / Math.max(state.terrainData.cols - 1, state.terrainData.rows - 1);
    for(let y=0; y<h; y++) {
      const ny = h === 1 ? 0 : y / (h - 1);
      for(let x=0; x<w; x++) {
        const nx = w === 1 ? 0 : x / (w - 1);
        const zNorm = getZInterpolated(nx, ny);
        const band = findBandIndex(zNorm, boundaries);
        const height = state.terrainData.min + zNorm;
        const elevationT = range.maxZ === range.minZ ? 0 : (height - range.minZ) / (range.maxZ - range.minZ);
        const shade = getHillshade(nx, ny, step, zNorm);
        const color = applyReliefOverlay(bandColors[band], shade, elevationT);
        const idx = (y * w + x) * 4;
        data[idx] = color.r;
        data[idx + 1] = color.g;
        data[idx + 2] = color.b;
        data[idx + 3] = alpha;
      }
    }
    ctx.putImageData(imgData, 0, 0);
    return cv.toDataURL('image/png');
  }

  function getContourSegments(level, widthMm, heightMm) {
    if(!state.terrainData) return [];
    const T = state.terrainData;
    const rows = T.rows;
    const cols = T.cols;
    const segments = [];
    const xScale = widthMm / (cols - 1);
    const yScale = heightMm / (rows - 1);
    const safeRatio = (num, den) => {
      if(den === 0) return 0.5;
      const t = num / den;
      if(!Number.isFinite(t)) return 0.5;
      return Math.max(0, Math.min(1, t));
    };

    const edgePoint = (edge, r, c, h00, h10, h11, h01) => {
      const x = c * xScale;
      const y = r * yScale;
      if(edge === 0) {
        const t = safeRatio(level - h00, h10 - h00);
        return [x + xScale * t, y];
      }
      if(edge === 1) {
        const t = safeRatio(level - h10, h11 - h10);
        return [x + xScale, y + yScale * t];
      }
      if(edge === 2) {
        const t = safeRatio(level - h11, h01 - h11);
        return [x + xScale * (1 - t), y + yScale];
      }
      const t = safeRatio(level - h01, h00 - h01);
      return [x, y + yScale * (1 - t)];
    };

    const table = {
      0: [],
      1: [[3,2]],
      2: [[2,1]],
      3: [[3,1]],
      4: [[0,1]],
      5: 'amb',
      6: [[0,2]],
      7: [[0,3]],
      8: [[0,3]],
      9: [[0,2]],
      10: 'amb',
      11: [[0,1]],
      12: [[3,1]],
      13: [[2,1]],
      14: [[3,2]],
      15: []
    };

    for(let r=0; r<rows-1; r++) {
      for(let c=0; c<cols-1; c++) {
        const h00 = T.h[r*cols + c];
        const h10 = T.h[r*cols + c + 1];
        const h01 = T.h[(r+1)*cols + c];
        const h11 = T.h[(r+1)*cols + c + 1];
        const tl = h00 >= level;
        const tr = h10 >= level;
        const br = h11 >= level;
        const bl = h01 >= level;
        const idx = (tl<<3) | (tr<<2) | (br<<1) | bl;
        if(idx === 0 || idx === 15) continue;
        const cellCenter = (h00 + h10 + h11 + h01) / 4;
        let pairs = table[idx];
        if(pairs === 'amb') {
          if(cellCenter >= level) {
            pairs = idx === 5 ? [[0,1],[2,3]] : [[0,3],[1,2]];
          } else {
            pairs = idx === 5 ? [[0,3],[1,2]] : [[0,1],[2,3]];
          }
        }
        pairs.forEach(pair => {
          const p1 = edgePoint(pair[0], r, c, h00, h10, h11, h01);
          const p2 = edgePoint(pair[1], r, c, h00, h10, h11, h01);
          if(isInShape(p1[0], p1[1]) && isInShape(p2[0], p2[1])) {
            segments.push([p1, p2]);
          }
        });
      }
    }
    return segments;
  }

  function buildPolylines(segments, precision = 2) {
    const keyFor = (p) => `${p[0].toFixed(precision)},${p[1].toFixed(precision)}`;
    const endpointMap = new Map();
    const used = new Array(segments.length).fill(false);
    segments.forEach((seg, i) => {
      [0,1].forEach(end => {
        const key = keyFor(seg[end]);
        if(!endpointMap.has(key)) endpointMap.set(key, []);
        endpointMap.get(key).push({ index: i, end });
      });
    });

    const takeNext = (key) => {
      const list = endpointMap.get(key);
      if(!list) return null;
      for(const item of list) {
        if(!used[item.index]) return item;
      }
      return null;
    };

    const lines = [];
    for(let i = 0; i < segments.length; i++) {
      if(used[i]) continue;
      used[i] = true;
      const base = segments[i];
      const line = [base[0], base[1]];

      let advanced = true;
      while(advanced) {
        advanced = false;
        const tailKey = keyFor(line[line.length - 1]);
        const next = takeNext(tailKey);
        if(next && next.index !== i) {
          used[next.index] = true;
          const seg = segments[next.index];
          const nextPoint = next.end === 0 ? seg[1] : seg[0];
          line.push(nextPoint);
          advanced = true;
        }
      }

      advanced = true;
      while(advanced) {
        advanced = false;
        const headKey = keyFor(line[0]);
        const next = takeNext(headKey);
        if(next && next.index !== i) {
          used[next.index] = true;
          const seg = segments[next.index];
          const nextPoint = next.end === 0 ? seg[1] : seg[0];
          line.unshift(nextPoint);
          advanced = true;
        }
      }
      lines.push(line);
    }
    return lines;
  }

  function smoothPolyline(points, iterations) {
    if(points.length < 3 || iterations <= 0) return points;
    const dist = (a, b) => Math.hypot(a[0] - b[0], a[1] - b[1]);
    const isClosed = dist(points[0], points[points.length - 1]) < 0.01;
    let pts = isClosed ? points.slice(0, -1) : points.slice();

    for(let i = 0; i < iterations; i++) {
      const nextPts = [];
      for(let p = 0; p < pts.length - 1; p++) {
        const a = pts[p];
        const b = pts[p + 1];
        nextPts.push([0.75 * a[0] + 0.25 * b[0], 0.75 * a[1] + 0.25 * b[1]]);
        nextPts.push([0.25 * a[0] + 0.75 * b[0], 0.25 * a[1] + 0.75 * b[1]]);
      }
      if(isClosed) {
        const a = pts[pts.length - 1];
        const b = pts[0];
        nextPts.push([0.75 * a[0] + 0.25 * b[0], 0.75 * a[1] + 0.25 * b[1]]);
        nextPts.push([0.25 * a[0] + 0.75 * b[0], 0.25 * a[1] + 0.75 * b[1]]);
      }
      pts = nextPts;
    }
    if(isClosed) pts.push(pts[0]);
    return pts;
  }

  function projectToSvg(lat, lon) {
    if(!state.bbox) return [0, 0];
    const { sw, ne } = state.bbox;
    const x = ((lon - sw.lng) / (ne.lng - sw.lng)) * state.wMm;
    const y = ((ne.lat - lat) / (ne.lat - sw.lat)) * state.hMm;
    return [x, y];
  }

  function pathFromCoords(coords, closePath) {
    if(!coords.length) return '';
    const d = coords.map((pt, idx) => `${idx ? 'L' : 'M'} ${pt[0].toFixed(2)} ${pt[1].toFixed(2)}`).join(' ');
    return closePath ? `${d} Z` : d;
  }

  function normalizeRing(coords) {
    if(coords.length < 3) return coords;
    const first = coords[0];
    const last = coords[coords.length - 1];
    const closed = Math.hypot(first[0] - last[0], first[1] - last[1]) < 1e-6;
    return closed ? coords : [...coords, first];
  }

  function joinLineSegments(segments, tolerance = 0.4) {
    if(!segments.length) return [];
    const remaining = segments.map(seg => seg.slice());
    const rings = [];
    const closeEnough = (a, b) => Math.hypot(a[0] - b[0], a[1] - b[1]) <= tolerance;
    while(remaining.length) {
      let ring = remaining.pop();
      let merged = true;
      while(merged) {
        merged = false;
        for(let i = remaining.length - 1; i >= 0; i--) {
          const seg = remaining[i];
          const segStart = seg[0];
          const segEnd = seg[seg.length - 1];
          const ringStart = ring[0];
          const ringEnd = ring[ring.length - 1];
          if(closeEnough(ringEnd, segStart)) {
            ring = ring.concat(seg.slice(1));
            remaining.splice(i, 1);
            merged = true;
            break;
          }
          if(closeEnough(ringEnd, segEnd)) {
            ring = ring.concat(seg.slice(0, -1).reverse());
            remaining.splice(i, 1);
            merged = true;
            break;
          }
          if(closeEnough(ringStart, segEnd)) {
            ring = seg.slice(0, -1).concat(ring);
            remaining.splice(i, 1);
            merged = true;
            break;
          }
          if(closeEnough(ringStart, segStart)) {
            ring = seg.slice(1).reverse().concat(ring);
            remaining.splice(i, 1);
            merged = true;
            break;
          }
        }
      }
      if(ring.length >= 3) {
        rings.push(normalizeRing(ring));
      }
    }
    return rings;
  }

  function getShapePathD() {
    const w = state.wMm;
    const h = state.hMm;
    if(['rect','din_l','din_p','sq'].includes(state.shape)) {
      return `M 0,0 H ${w} V ${h} H 0 Z`;
    }
    if(state.shape === 'circle') {
      const r = w / 2;
      return `M ${w / 2},${h / 2} m -${r},0 a ${r},${r} 0 1,0 ${w},0 a ${r},${r} 0 1,0 -${w},0`;
    }
    if(state.shape === 'hex') {
      const r = w / 2;
      const cx = w / 2;
      const cy = h / 2;
      const pts = [];
      for(let i=0; i<6; i++) {
        const a = i * Math.PI / 3 - Math.PI / 6;
        pts.push([cx + r * Math.cos(a), cy + r * Math.sin(a)]);
      }
      return `M ${pts[0][0]},${pts[0][1]} ` + pts.slice(1).map(p=>`L ${p[0]},${p[1]}`).join(' ') + ' Z';
    }
    return `M 0,0 H ${w} V ${h} H 0 Z`;
  }

  const overpassServers = [
    'https://overpass-api.de/api/interpreter',
    'https://overpass.kumi.systems/api/interpreter',
    'https://overpass.nchc.org.tw/api/interpreter'
  ];

  const buildOverpassQuery = (bbox) => `[out:json][timeout:25];
    (
      way["natural"="water"](${bbox});
      way["water"~"sea|ocean"](${bbox});
      way["waterway"="riverbank"](${bbox});
      relation["natural"="water"](${bbox});
      relation["water"~"sea|ocean"](${bbox});
      relation["waterway"="riverbank"](${bbox});
      way["waterway"~"river|stream|canal"](${bbox});
      way["landuse"~"forest|grass|meadow|recreation_ground"](${bbox});
      way["leisure"~"park|garden"](${bbox});
      way["natural"~"wood|grassland"](${bbox});
      relation["landuse"~"forest|grass|meadow|recreation_ground"](${bbox});
      relation["leisure"~"park|garden"](${bbox});
      relation["natural"~"wood|grassland"](${bbox});
      way["highway"~"motorway|trunk|primary|secondary|tertiary|residential|unclassified|service"](${bbox});
      relation["highway"~"motorway|trunk|primary|secondary|tertiary|residential|unclassified|service"](${bbox});
      node["place"~"city|town|village|suburb|hamlet|neighbourhood"](${bbox});
    );
    out geom;`;

  const buildEmptyOsmData = () => ({
    waterPolygons: [],
    greenPolygons: [],
    waterLines: [],
    roadLines: [],
    places: []
  });

  const parseOverpassElements = (elements, target) => {
    const greenLanduse = new Set(['forest', 'grass', 'meadow', 'recreation_ground']);
    const greenLeisure = new Set(['park', 'garden']);
    const greenNatural = new Set(['wood', 'grassland']);
    const waterLinesSet = new Set(['river', 'stream', 'canal']);
    const waterAreaSet = new Set(['sea', 'ocean']);

    const toSvgCoords = (geometry) => geometry.map(p => projectToSvg(p.lat, p.lon));

    elements.forEach((el) => {
      const tags = el.tags || {};
      if(el.type === 'node' && tags.name && tags.place) {
        target.places.push({ name: tags.name, lat: el.lat, lon: el.lon, place: tags.place });
        return;
      }
      if(el.type === 'way' && Array.isArray(el.geometry)) {
        const coords = toSvgCoords(el.geometry);
        if(tags.waterway && waterLinesSet.has(tags.waterway)) {
          target.waterLines.push(coords);
          return;
        }
        if(tags.highway) {
          target.roadLines.push(coords);
          return;
        }
        const isWater = tags.natural === 'water' || tags.waterway === 'riverbank' || waterAreaSet.has(tags.water);
        const isGreen = greenLanduse.has(tags.landuse) || greenLeisure.has(tags.leisure) || greenNatural.has(tags.natural);
        if(isWater) {
          target.waterPolygons.push(normalizeRing(coords));
          return;
        }
        if(isGreen) {
          target.greenPolygons.push(normalizeRing(coords));
        }
        return;
      }
      if(el.type === 'relation' && Array.isArray(el.members)) {
        const relationSegments = el.members
          .filter(m => m.role === 'outer' && Array.isArray(m.geometry))
          .map(m => toSvgCoords(m.geometry));
        const relationPolys = joinLineSegments(relationSegments);
        const isWater = tags.natural === 'water' || tags.waterway === 'riverbank' || waterAreaSet.has(tags.water);
        const isGreen = greenLanduse.has(tags.landuse) || greenLeisure.has(tags.leisure) || greenNatural.has(tags.natural);
        if(isWater) {
          target.waterPolygons.push(...(relationPolys.length ? relationPolys : relationSegments.map(normalizeRing)));
        }
        if(isGreen) {
          target.greenPolygons.push(...(relationPolys.length ? relationPolys : relationSegments.map(normalizeRing)));
        }
        if(tags.highway) {
          const relationLines = el.members
            .filter(m => Array.isArray(m.geometry))
            .map(m => toSvgCoords(m.geometry));
          target.roadLines.push(...relationLines);
        }
      }
    });
  };

  const fetchOverpass = async (query) => {
    let lastError = null;
    for(const server of overpassServers) {
      try {
        const res = await fetch(server, {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: `data=${encodeURIComponent(query)}`
        });
        if(!res.ok) {
          throw new Error(`Overpass error ${res.status}`);
        }
        return await res.json();
      } catch (err) {
        lastError = err;
      }
    }
    throw lastError || new Error('Overpass error');
  };

  const getTiledBboxes = (sw, ne) => {
    const midLat = (sw.lat + ne.lat) / 2;
    const midLng = (sw.lng + ne.lng) / 2;
    return [
      { sw: { lat: sw.lat, lng: sw.lng }, ne: { lat: midLat, lng: midLng } },
      { sw: { lat: sw.lat, lng: midLng }, ne: { lat: midLat, lng: ne.lng } },
      { sw: { lat: midLat, lng: sw.lng }, ne: { lat: ne.lat, lng: midLng } },
      { sw: { lat: midLat, lng: midLng }, ne: { lat: ne.lat, lng: ne.lng } }
    ];
  };

  async function fetchMapFeatures(sw, ne) {
    state.osmStatus = { loaded: false, error: null, tiles: 1, ignored: false };
    const attemptFetch = async (bboxes) => {
      const osmData = buildEmptyOsmData();
      for(const bbox of bboxes) {
        const bboxStr = `${bbox.sw.lat},${bbox.sw.lng},${bbox.ne.lat},${bbox.ne.lng}`;
        const data = await fetchOverpass(buildOverpassQuery(bboxStr));
        parseOverpassElements(data.elements || [], osmData);
      }
      const placeRank = { city: 1, town: 2, village: 3, suburb: 4, neighbourhood: 5, hamlet: 6 };
      osmData.places.sort((a, b) => (placeRank[a.place] || 99) - (placeRank[b.place] || 99));
      osmData.places = osmData.places.slice(0, 28);
      return osmData;
    };

    try {
      state.osmData = await attemptFetch([{ sw, ne }]);
      state.osmStatus.loaded = true;
      state.osmStatus.tiles = 1;
      updateMapDataStatus();
      return true;
    } catch (err) {
      try {
        const tiledBboxes = getTiledBboxes(sw, ne);
        state.osmData = await attemptFetch(tiledBboxes);
        state.osmStatus.loaded = true;
        state.osmStatus.tiles = tiledBboxes.length;
        updateMapDataStatus();
        return true;
      } catch (tileErr) {
        state.osmData = buildEmptyOsmData();
        state.osmStatus.error = 'Straen, Fl眉sse oder Fl盲chen konnten nicht geladen werden. Bitte w盲hle einen kleineren Ausschnitt oder versuche es erneut.';
        updateMapDataStatus();
        return false;
      }
    }
  }

  // --- MAP & SEARCH ---
  const map = L.map('map', { zoomControl:false, preferCanvas:true }).setView([48.137, 11.575], 14);
  L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
    maxZoom: 17,
    attribution: '&copy; OpenTopoMap contributors &copy; OpenStreetMap'
  }).addTo(map);

  let timer;
  let activeSearch = null;
  $('searchInp').addEventListener('input', (e) => {
    clearTimeout(timer);
    const val = e.target.value;
    if(val.length<3) { $('suggestionBox').style.display='none'; return; }
    timer = setTimeout(async () => {
      try {
        if(activeSearch) {
          activeSearch.abort();
        }
        activeSearch = new AbortController();
        const r = await fetch(
          `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(val)}&limit=5`,
          { signal: activeSearch.signal }
        );
        const d = await r.json();
        const box = $('suggestionBox'); box.innerHTML='';
        if(d.length) {
          d.forEach(i => {
            const div = document.createElement('div'); div.className = 'suggestion-item';
            div.innerText = i.display_name.split(',').slice(0,3).join(',');
            div.onclick = () => { map.setView([i.lat,i.lon], 14); box.style.display='none'; $('searchInp').value=div.innerText; };
            box.appendChild(div);
          });
          box.style.display='block';
        }
      } catch(e) {
        if (e.name !== 'AbortError') {
          $('suggestionBox').style.display='none';
        }
      }
    }, 400);
  });

  // --- UI CONSTRUCTION ---
  document.querySelectorAll('.layer-head').forEach((head) => {
    head.onclick = (e) => {
      const item = e.currentTarget.closest('.layer-item');
      if(item?.classList.contains('dragging')) return;
      item.classList.toggle('open');
    };
  });
  document.querySelectorAll('.layer-head .ios-switch').forEach((toggle) => {
    toggle.addEventListener('click', (e) => {
      e.stopPropagation();
    });
  });

  const setupLayerReorder = (container) => {
    if(!container) return;
    let draggedItem = null;
    const items = Array.from(container.querySelectorAll('[draggable="true"]'));
    items.forEach((item) => {
      let handleActive = false;
      const dragHandle = item.querySelector('.drag-handle');
      if(dragHandle) {
        dragHandle.addEventListener('pointerdown', () => { handleActive = true; });
        dragHandle.addEventListener('pointerup', () => { handleActive = false; });
        dragHandle.addEventListener('pointerleave', () => { handleActive = false; });
      }
      item.addEventListener('dragstart', (e) => {
        if(!handleActive) {
          e.preventDefault();
          return;
        }
        draggedItem = item;
        item.classList.add('dragging');
        if(e.dataTransfer) {
          e.dataTransfer.effectAllowed = 'move';
        }
      });
      item.addEventListener('dragend', () => {
        item.classList.remove('dragging');
        draggedItem = null;
        handleActive = false;
      });
      item.addEventListener('dragover', (e) => {
        e.preventDefault();
      });
      item.addEventListener('drop', (e) => {
        e.preventDefault();
        if(!draggedItem || draggedItem === item) return;
        const siblings = Array.from(container.children).filter(el => el.dataset.layer);
        const draggedIndex = siblings.indexOf(draggedItem);
        const targetIndex = siblings.indexOf(item);
        if(draggedIndex < targetIndex) {
          container.insertBefore(draggedItem, item.nextSibling);
        } else {
          container.insertBefore(draggedItem, item);
        }
        state.layerOrder = Array.from(container.children).filter(el => el.dataset.layer).map(el => el.dataset.layer);
        markPreviewDirty();
      });
    });
  };

  const layerStack = $('layerStack');
  setupLayerReorder(layerStack);

  const stepButtons = document.querySelectorAll('[data-step-target]');
  const stepContents = document.querySelectorAll('.step-content');
  const setStep = (step) => {
    stepButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.stepTarget === step));
    stepContents.forEach(section => section.classList.toggle('active', section.dataset.step === step));
  };
  stepButtons.forEach(btn => btn.addEventListener('click', () => setStep(btn.dataset.stepTarget)));
  const toExport = $('toExport');
  if(toExport) toExport.addEventListener('click', () => setStep('3'));
  const backToStyle = $('backToStyle');
  if(backToStyle) backToStyle.addEventListener('click', () => setStep('2'));
  if(refreshPreviewBtn) {
    refreshPreviewBtn.addEventListener('click', () => {
      if(!state.terrainData) return;
      renderSVG();
    });
  }

  const presets = {
    dark: {
      background: '#141A22',
      line: '#D7E3FF',
      mapFeatures: {
        waterAreas: '#4C86A8',
        rivers: '#4C86A8',
        greenAreas: '#4E7E5A',
        roads: '#E7C36E',
        labels: '#F5F7FB'
      }
    },
    bright: {
      background: '#F5F2EB',
      line: '#10141B',
      mapFeatures: {
        waterAreas: '#7DB5D3',
        rivers: '#7DB5D3',
        greenAreas: '#7FAE8A',
        roads: '#C9A75A',
        labels: '#1E232B'
      }
    },
    grayscale: {
      background: '#1C1C1C',
      line: '#D6D6D6',
      mapFeatures: {
        waterAreas: '#5A5A5A',
        rivers: '#5A5A5A',
        greenAreas: '#444444',
        roads: '#8C8C8C',
        labels: '#F2F2F2'
      }
    }
  };

  const parseColorInput = (value) => {
    const v = value.trim();
    if(!v) return null;
    const tester = new Option().style;
    tester.color = v;
    return tester.color ? tester.color : null;
  };

  const rgbToHex = (rgb) => {
    const match = rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
    if(!match) return null;
    const toHex = (n) => n.toString(16).padStart(2, '0');
    return `#${toHex(parseInt(match[1], 10))}${toHex(parseInt(match[2], 10))}${toHex(parseInt(match[3], 10))}`.toUpperCase();
  };

  const toPercent = (value) => {
    const parsed = parseFloat(value);
    if(Number.isNaN(parsed)) return 0;
    return Math.min(100, Math.max(0, parsed));
  };

  const formatPercent = (value) => `${Math.round(value)}%`;
  const toUnitOpacity = (value) => Math.min(1, Math.max(0, value / 100));
  const formatSignedPercent = (value) => {
    const rounded = Math.round(value);
    return `${rounded > 0 ? '+' : ''}${rounded}%`;
  };

  const updateRefreshButton = () => {
    if(!refreshPreviewBtn) return;
    refreshPreviewBtn.disabled = !state.terrainData || !state.previewDirty;
  };

  const markPreviewDirty = () => {
    if(!state.terrainData) return;
    state.previewDirty = true;
    updateRefreshButton();
  };

  const applyTheme = () => {
    $('previewArea').style.background = state.theme.background;
    state.contour.color = state.theme.line;
    $('contourColor').value = state.contour.color;
    $('contourColor').parentElement.style.background = state.contour.color;
    markPreviewDirty();
  };

  const syncWaterColors = (color) => {
    state.mapFeatures.waterAreas.color = color;
    state.mapFeatures.rivers.color = color;
    $('waterAreaColor').value = color;
    $('waterAreaColorDot').style.background = color;
    $('riverColor').value = color;
    $('riverColorDot').style.background = color;
  };

  const applyPresetMapFeatures = (preset) => {
    if(!preset?.mapFeatures) return;
    syncWaterColors(preset.mapFeatures.waterAreas);
    state.mapFeatures.greenAreas.color = preset.mapFeatures.greenAreas;
    $('greenAreaColor').value = state.mapFeatures.greenAreas.color;
    $('greenAreaColorDot').style.background = state.mapFeatures.greenAreas.color;
    state.mapFeatures.roads.color = preset.mapFeatures.roads;
    $('roadColor').value = state.mapFeatures.roads.color;
    $('roadColorDot').style.background = state.mapFeatures.roads.color;
    state.mapFeatures.labels.color = preset.mapFeatures.labels;
    $('labelColor').value = state.mapFeatures.labels.color;
    $('labelColorDot').style.background = state.mapFeatures.labels.color;
  };

  const updateMapDataStatus = () => {
    const statusEl = $('mapDataStatus');
    if(!statusEl) return;
    if(!state.osmStatus) {
      statusEl.textContent = 'Map data: --';
      statusEl.className = 'status-pill';
      return;
    }
    if(state.osmStatus.loaded && state.osmData) {
      const tilesLabel = state.osmStatus.tiles > 1 ? ` 路 ${state.osmStatus.tiles} tiles` : '';
      statusEl.textContent = `Map data loaded: Water ${state.osmData.waterPolygons.length}, Rivers ${state.osmData.waterLines.length}, Roads ${state.osmData.roadLines.length}, Green ${state.osmData.greenPolygons.length}, Labels ${state.osmData.places.length}${tilesLabel}`;
      statusEl.className = 'status-pill ok';
      return;
    }
    if(state.osmStatus.error) {
      const suffix = state.osmStatus.ignored ? ' (ignored)' : '';
      statusEl.textContent = `Map data missing${suffix}: ${state.osmStatus.error}`;
      statusEl.className = 'status-pill error';
      return;
    }
    statusEl.textContent = 'Map data: --';
    statusEl.className = 'status-pill';
  };

  const syncCustomField = (value, pickerId, textId, dotId) => {
    const parsed = parseColorInput(value);
    if(!parsed) return;
    const hex = parsed.startsWith('rgb') ? rgbToHex(parsed) : parsed;
    if(hex) $(pickerId).value = hex;
    $(textId).value = value;
    $(dotId).style.background = parsed;
  };

  $('presetSel').onchange = (e) => {
    const preset = e.target.value;
    const presetConfig = presets[preset];
    state.theme.preset = preset;
    state.theme.background = presetConfig.background;
    state.theme.line = presetConfig.line;
    $('bgColorPicker').value = state.theme.background;
    $('lineColorPicker').value = state.theme.line;
    $('bgColorText').value = state.theme.background;
    $('lineColorText').value = state.theme.line;
    $('bgColorDot').style.background = state.theme.background;
    $('lineColorDot').style.background = state.theme.line;
    applyPresetMapFeatures(presetConfig);
    applyTheme();
  };

  $('bgColorPicker').oninput = (e) => {
    state.theme.background = e.target.value;
    $('bgColorDot').style.background = state.theme.background;
    $('bgColorText').value = state.theme.background;
    applyTheme();
  };
  $('lineColorPicker').oninput = (e) => {
    state.theme.line = e.target.value;
    $('lineColorDot').style.background = state.theme.line;
    $('lineColorText').value = state.theme.line;
    applyTheme();
  };
  $('bgColorText').onchange = (e) => {
    const parsed = parseColorInput(e.target.value);
    if(!parsed) return;
    state.theme.background = parsed.startsWith('rgb') ? parsed : e.target.value;
    syncCustomField(parsed, 'bgColorPicker', 'bgColorText', 'bgColorDot');
    applyTheme();
  };
  $('lineColorText').onchange = (e) => {
    const parsed = parseColorInput(e.target.value);
    if(!parsed) return;
    state.theme.line = parsed.startsWith('rgb') ? parsed : e.target.value;
    syncCustomField(parsed, 'lineColorPicker', 'lineColorText', 'lineColorDot');
    applyTheme();
  };

  $('contourColor').oninput = (e) => {
    state.contour.color = e.target.value;
    e.target.parentElement.style.background = state.contour.color;
    state.theme.line = state.contour.color;
    $('lineColorPicker').value = state.contour.color;
    $('lineColorText').value = state.contour.color;
    $('lineColorDot').style.background = state.contour.color;
    markPreviewDirty();
  };

  $('contourWidth').oninput = (e) => {
    state.contour.width = parseFloat(e.target.value);
    $('contourWidthVal').innerText = state.contour.width.toFixed(2).replace(/\.00$/, '');
    markPreviewDirty();
  };

  $('contourDensity').oninput = (e) => {
    state.contour.density = parseInt(e.target.value, 10);
    $('contourDensityVal').innerText = state.contour.density;
    markPreviewDirty();
  };

  $('contourOpacity').oninput = (e) => {
    state.contour.opacity = toPercent(e.target.value);
    $('contourOpacityVal').innerText = formatPercent(state.contour.opacity);
    markPreviewDirty();
  };

  $('contourSmooth').oninput = (e) => {
    state.contour.smooth = parseInt(e.target.value, 10);
    $('contourSmoothVal').innerText = state.contour.smooth;
    markPreviewDirty();
  };

  $('contourToggle').onclick = function() {
    state.contour.enabled = !state.contour.enabled;
    this.classList.toggle('on', state.contour.enabled);
    markPreviewDirty();
  };

  $('waterAreaToggle').onclick = function() {
    state.mapFeatures.waterAreas.enabled = !state.mapFeatures.waterAreas.enabled;
    this.classList.toggle('on', state.mapFeatures.waterAreas.enabled);
    markPreviewDirty();
  };
  $('waterAreaColor').oninput = (e) => {
    syncWaterColors(e.target.value);
    markPreviewDirty();
  };
  $('waterAreaOpacity').oninput = (e) => {
    state.mapFeatures.waterAreas.opacity = toPercent(e.target.value);
    $('waterAreaOpacityVal').innerText = formatPercent(state.mapFeatures.waterAreas.opacity);
    markPreviewDirty();
  };
  $('riverToggle').onclick = function() {
    state.mapFeatures.rivers.enabled = !state.mapFeatures.rivers.enabled;
    this.classList.toggle('on', state.mapFeatures.rivers.enabled);
    markPreviewDirty();
  };
  $('riverColor').oninput = (e) => {
    syncWaterColors(e.target.value);
    markPreviewDirty();
  };
  $('riverWidth').oninput = (e) => {
    state.mapFeatures.rivers.width = parseFloat(e.target.value);
    $('riverWidthVal').innerText = state.mapFeatures.rivers.width.toFixed(2).replace(/\.00$/, '');
    markPreviewDirty();
  };
  $('riverOpacity').oninput = (e) => {
    state.mapFeatures.rivers.opacity = toPercent(e.target.value);
    $('riverOpacityVal').innerText = formatPercent(state.mapFeatures.rivers.opacity);
    markPreviewDirty();
  };
  $('greenAreaToggle').onclick = function() {
    state.mapFeatures.greenAreas.enabled = !state.mapFeatures.greenAreas.enabled;
    this.classList.toggle('on', state.mapFeatures.greenAreas.enabled);
    markPreviewDirty();
  };
  $('greenAreaColor').oninput = (e) => {
    state.mapFeatures.greenAreas.color = e.target.value;
    $('greenAreaColorDot').style.background = state.mapFeatures.greenAreas.color;
    markPreviewDirty();
  };
  $('greenAreaOpacity').oninput = (e) => {
    state.mapFeatures.greenAreas.opacity = toPercent(e.target.value);
    $('greenAreaOpacityVal').innerText = formatPercent(state.mapFeatures.greenAreas.opacity);
    markPreviewDirty();
  };
  $('roadToggle').onclick = function() {
    state.mapFeatures.roads.enabled = !state.mapFeatures.roads.enabled;
    this.classList.toggle('on', state.mapFeatures.roads.enabled);
    markPreviewDirty();
  };
  $('roadColor').oninput = (e) => {
    state.mapFeatures.roads.color = e.target.value;
    $('roadColorDot').style.background = state.mapFeatures.roads.color;
    markPreviewDirty();
  };
  $('roadWidth').oninput = (e) => {
    state.mapFeatures.roads.width = parseFloat(e.target.value);
    $('roadWidthVal').innerText = state.mapFeatures.roads.width.toFixed(2).replace(/\.00$/, '');
    markPreviewDirty();
  };
  $('roadOpacity').oninput = (e) => {
    state.mapFeatures.roads.opacity = toPercent(e.target.value);
    $('roadOpacityVal').innerText = formatPercent(state.mapFeatures.roads.opacity);
    markPreviewDirty();
  };
  $('labelToggle').onclick = function() {
    state.mapFeatures.labels.enabled = !state.mapFeatures.labels.enabled;
    this.classList.toggle('on', state.mapFeatures.labels.enabled);
    markPreviewDirty();
  };
  $('labelColor').oninput = (e) => {
    state.mapFeatures.labels.color = e.target.value;
    $('labelColorDot').style.background = state.mapFeatures.labels.color;
    markPreviewDirty();
  };
  $('labelOpacity').oninput = (e) => {
    state.mapFeatures.labels.opacity = toPercent(e.target.value);
    $('labelOpacityVal').innerText = formatPercent(state.mapFeatures.labels.opacity);
    markPreviewDirty();
  };
  $('labelSize').oninput = (e) => {
    state.mapFeatures.labels.size = parseFloat(e.target.value);
    $('labelSizeVal').innerText = state.mapFeatures.labels.size.toFixed(2).replace(/\.00$/, '');
    markPreviewDirty();
  };
  $('labelFont').onchange = (e) => {
    state.mapFeatures.labels.font = e.target.value;
    markPreviewDirty();
  };
  const buildHypsometricPreview = (scheme) => {
    const stops = getHypsometricStops(scheme);
    const step = 100 / stops.length;
    const segments = stops.map((color, idx) => {
      const start = (idx * step).toFixed(2);
      const end = ((idx + 1) * step).toFixed(2);
      return `${color} ${start}%, ${color} ${end}%`;
    });
    return `linear-gradient(90deg, ${segments.join(', ')})`;
  };

  const updateGradientPreview = () => {
    $('pngGradientPreview').style.background = buildHypsometricPreview(state.png.scheme);
  };

  const updatePngRangeInfo = () => {
    const range = getShapeHeightRange();
    if(!range) {
      $('pngRangeInfo').innerText = 'Range: --';
      return;
    }
    $('pngRangeInfo').innerText = `Range: ${Math.round(range.minZ)} m  ${Math.round(range.maxZ)} m`;
  };

  $('pngResRange').oninput = (e) => { $('pngResVal').innerText = e.target.value + 'px'; };

  $('pngLayerToggle').onclick = function() {
    state.png.layered = !state.png.layered;
    this.classList.toggle('on', state.png.layered);
    $('pngLayerOptions').style.display = state.png.layered ? 'block' : 'none';
    updateGradientPreview();
    updatePngRangeInfo();
    markPreviewDirty();
  };

  $('pngScheme').onchange = (e) => {
    state.png.scheme = e.target.value;
    updateGradientPreview();
    if(state.png.layered) markPreviewDirty();
  };
  $('pngGradOpacity').oninput = (e) => {
    state.png.gradientOpacity = toPercent(e.target.value);
    $('pngGradOpacityVal').innerText = formatPercent(state.png.gradientOpacity);
    if(state.png.layered) markPreviewDirty();
  };
  $('pngGradShift').oninput = (e) => {
    state.png.gradientShift = parseFloat(e.target.value);
    $('pngGradShiftVal').innerText = formatSignedPercent(state.png.gradientShift);
    if(state.png.layered) markPreviewDirty();
  };
  $('pngGradScale').oninput = (e) => {
    state.png.gradientScale = parseFloat(e.target.value);
    $('pngGradScaleVal').innerText = formatPercent(state.png.gradientScale);
    if(state.png.layered) markPreviewDirty();
  };

  $('shapeSel').onchange = (e) => {
    state.shape = e.target.value;
    $('dimH').disabled = ['sq','circle','hex','din_l','din_p'].includes(state.shape);
    updateVf();
  };
  ['dimW','dimH'].forEach(id => $(id).oninput = updateVf);

  $('presetSel').value = state.theme.preset;
  $('bgColorText').value = state.theme.background;
  $('lineColorText').value = state.theme.line;
  $('bgColorDot').style.background = state.theme.background;
  $('lineColorDot').style.background = state.theme.line;
  $('contourToggle').classList.toggle('on', state.contour.enabled);
  $('contourOpacity').value = state.contour.opacity;
  $('contourOpacityVal').innerText = formatPercent(state.contour.opacity);
  $('waterAreaToggle').classList.toggle('on', state.mapFeatures.waterAreas.enabled);
  $('waterAreaColor').value = state.mapFeatures.waterAreas.color;
  $('waterAreaColorDot').style.background = state.mapFeatures.waterAreas.color;
  $('waterAreaOpacity').value = state.mapFeatures.waterAreas.opacity;
  $('waterAreaOpacityVal').innerText = formatPercent(state.mapFeatures.waterAreas.opacity);
  $('riverToggle').classList.toggle('on', state.mapFeatures.rivers.enabled);
  $('riverColor').value = state.mapFeatures.rivers.color;
  $('riverColorDot').style.background = state.mapFeatures.rivers.color;
  $('riverWidth').value = state.mapFeatures.rivers.width;
  $('riverWidthVal').innerText = state.mapFeatures.rivers.width.toFixed(2).replace(/\.00$/, '');
  $('riverOpacity').value = state.mapFeatures.rivers.opacity;
  $('riverOpacityVal').innerText = formatPercent(state.mapFeatures.rivers.opacity);
  $('greenAreaToggle').classList.toggle('on', state.mapFeatures.greenAreas.enabled);
  $('greenAreaColor').value = state.mapFeatures.greenAreas.color;
  $('greenAreaColorDot').style.background = state.mapFeatures.greenAreas.color;
  $('greenAreaOpacity').value = state.mapFeatures.greenAreas.opacity;
  $('greenAreaOpacityVal').innerText = formatPercent(state.mapFeatures.greenAreas.opacity);
  $('roadToggle').classList.toggle('on', state.mapFeatures.roads.enabled);
  $('roadColor').value = state.mapFeatures.roads.color;
  $('roadColorDot').style.background = state.mapFeatures.roads.color;
  $('roadWidth').value = state.mapFeatures.roads.width;
  $('roadWidthVal').innerText = state.mapFeatures.roads.width.toFixed(2).replace(/\.00$/, '');
  $('roadOpacity').value = state.mapFeatures.roads.opacity;
  $('roadOpacityVal').innerText = formatPercent(state.mapFeatures.roads.opacity);
  $('labelToggle').classList.toggle('on', state.mapFeatures.labels.enabled);
  $('labelColor').value = state.mapFeatures.labels.color;
  $('labelColorDot').style.background = state.mapFeatures.labels.color;
  $('labelOpacity').value = state.mapFeatures.labels.opacity;
  $('labelOpacityVal').innerText = formatPercent(state.mapFeatures.labels.opacity);
  $('labelSize').value = state.mapFeatures.labels.size;
  $('labelSizeVal').innerText = state.mapFeatures.labels.size.toFixed(2).replace(/\.00$/, '');
  $('labelFont').value = state.mapFeatures.labels.font;
  $('pngScheme').value = state.png.scheme;
  $('pngGradOpacity').value = state.png.gradientOpacity;
  $('pngGradOpacityVal').innerText = formatPercent(state.png.gradientOpacity);
  $('pngGradShift').value = state.png.gradientShift;
  $('pngGradShiftVal').innerText = formatSignedPercent(state.png.gradientShift);
  $('pngGradScale').value = state.png.gradientScale;
  $('pngGradScaleVal').innerText = formatPercent(state.png.gradientScale);
  $('pngLayerToggle').classList.toggle('on', state.png.layered);
  $('pngLayerOptions').style.display = state.png.layered ? 'block' : 'none';
  if(layerStack) {
    state.layerOrder.forEach((key) => {
      const item = layerStack.querySelector(`[data-layer="${key}"]`);
      if(item) layerStack.appendChild(item);
    });
  }
  updateGradientPreview();
  applyTheme();
  updateMapDataStatus();
  updateRefreshButton();

  function updateVf() {
    state.wMm = +$('dimW').value; state.hMm = +$('dimH').value;
    if(['sq','circle','hex'].includes(state.shape)) { state.hMm = state.wMm; $('dimH').value = state.wMm; }
    if(state.shape === 'din_l') { state.hMm = Math.round(state.wMm / 1.414); $('dimH').value = state.hMm; }
    if(state.shape === 'din_p') { state.hMm = Math.round(state.wMm * 1.414); $('dimH').value = state.hMm; }

    const winW = window.innerWidth, winH = window.innerHeight;
    const sideW = document.querySelector('.sidebar')?.offsetWidth || 400;
    const headerH = document.querySelector('.top-header')?.offsetHeight || 0;
    const pad = 24;
    const availW = Math.max(0, winW - sideW - pad * 2);
    const availH = Math.max(0, winH - headerH - pad * 2);
    const cx = sideW + pad + availW / 2;
    const cy = headerH + pad + availH / 2;
    const ratio = state.hMm / state.wMm;
    const targetW = availW * 0.78, targetH = availH * 0.78;
    let pxW, pxH;
    if(targetW*ratio <= targetH) { pxW=targetW; pxH=pxW*ratio; } else { pxH=targetH; pxW=pxH/ratio; }
    const hw = pxW/2, hh = pxH/2;
    let d = '';
    if(['rect','din_l','din_p','sq'].includes(state.shape)) d = `M ${cx-hw},${cy-hh} H ${cx+hw} V ${cy+hh} H ${cx-hw} Z`;
    else if(state.shape === 'circle') d = `M ${cx},${cy} m -${hw},0 a ${hw},${hw} 0 1,0 ${pxW},0 a ${hw},${hw} 0 1,0 -${pxW},0`;
    else if(state.shape === 'hex') {
      const r = hw, pts = [];
      for(let i=0;i<6;i++){ const a = i*Math.PI/3 - Math.PI/6; pts.push([cx+r*Math.cos(a), cy+r*Math.sin(a)]); }
      d = `M ${pts[0][0]},${pts[0][1]} ` + pts.slice(1).map(p=>`L ${p[0]},${p[1]}`).join(' ') + ' Z';
    }
    $('vfHole').setAttribute('d', d); $('vfOutline').setAttribute('d', d);
    $('vfBadge').style.left = cx+'px';
    $('vfBadge').style.top = (cy+hh)+'px';
    $('vfBadge').innerText = `${state.wMm}  ${state.hMm} mm`;
    state.bbox = { sw: map.containerPointToLatLng([cx-hw, cy+hh]), ne: map.containerPointToLatLng([cx+hw, cy-hh]) };
    if(state.terrainData) updatePngRangeInfo();
  }
  window.onresize = updateVf; map.on('move zoom', updateVf); setTimeout(updateVf,500);

  // --- GENERATION PIPELINE ---
  $('btnGen').onclick = async () => {
    msg('Fetching Elevation Data...');
    const {sw, ne} = state.bbox;
    await fetchTerrain(sw, ne);
    msg('Fetching Map Features...');
    const mapOk = await fetchMapFeatures(sw, ne);
    if(!state.terrainData) {
      renderSVG();
      idle();
      $('modal').classList.add('open');
      alert('Elevation data unavailable. Try a smaller area or try again.');
      return;
    }
    if(!mapOk) {
      idle();
      const proceed = confirm('Kartendaten (Straen, Fl眉sse, Wasser/Gr眉nfl盲chen) konnten nicht geladen werden.\n\nM枚chtest du trotzdem fortfahren?\nAbbrechen, um einen neuen Ausschnitt zu w盲hlen.');
      if(!proceed) {
        return;
      }
      state.osmStatus.ignored = true;
      updateMapDataStatus();
    }
    renderSVG();
    idle();
    setStep('2');
    $('modal').classList.add('open');
  };

  async function fetchTerrain(sw, ne) {
    try {
      const rows = 120;
      const cols = rows;
      const locs=[];
      const dLat = (ne.lat-sw.lat)/(rows-1), dLon = (ne.lng-sw.lng)/(cols-1);
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) locs.push({latitude:sw.lat+r*dLat, longitude:sw.lng+c*dLon});
      const res = await fetch('https://api.open-elevation.com/api/v1/lookup', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({locations:locs})});
      const j = await res.json();
      let h = j.results.map(x=>x.elevation);
      // Smooth based on detail: higher detail keeps more variation.
      const smoothPasses = 4;
      for(let i=0; i<smoothPasses; i++) h = smoothPass(h, rows, cols);
      let min=Infinity, max=-Infinity; h.forEach(v => { if(v<min) min=v; if(v>max) max=v; });
      state.terrainData = { rows, cols, h: h.map(z=>z-min), min, max, delta: max-min };
    } catch(e) { state.terrainData = null; }
  }

  function smoothPass(data, rows, cols) {
    const out = new Float32Array(data.length);
    for(let r=0; r<rows; r++) for(let c=0; c<cols; c++) {
      let sum=0, wSum=0;
      for(let rr=r-1; rr<=r+1; rr++) for(let cc=c-1; cc<=c+1; cc++) {
        if(rr>=0 && rr<rows && cc>=0 && cc<cols) {
          const w = (rr===r && cc===c) ? 8 : 1; sum+=data[rr*cols+cc]*w; wSum+=w;
        }
      }
      out[r*cols+c] = sum/wSum;
    }
    return out;
  }

  function buildSvgMarkup({ includeBackground = true, includeGradient = true, includeFrame = true } = {}) {
    const {wMm, hMm} = state;
    let svg = `<svg id="prevSvg" width="${wMm}mm" height="${hMm}mm" viewBox="0 0 ${wMm} ${hMm}" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">`;
    const clipPathD = getShapePathD();
    svg += `<defs><clipPath id="shapeClip"><path d="${clipPathD}"/></clipPath></defs>`;
    svg += `<g clip-path="url(#shapeClip)">`;
    if(includeBackground) {
      svg += `<rect width="100%" height="100%" fill="${state.theme.background}"/>`;
    }
    if(includeGradient && state.png.layered && state.terrainData) {
      const previewUrl = getLayeredPreviewDataUrl();
      if(previewUrl) {
        svg += `<image href="${previewUrl}" x="0" y="0" width="${wMm}" height="${hMm}" preserveAspectRatio="none" />`;
      }
    }

    const layers = {
      green: () => {
        if(!state.osmData || !state.mapFeatures.greenAreas.enabled || !state.osmData.greenPolygons.length) return '';
        let out = `<g id="greenAreas" fill="${state.mapFeatures.greenAreas.color}" fill-opacity="${toUnitOpacity(state.mapFeatures.greenAreas.opacity)}">`;
        state.osmData.greenPolygons.forEach((poly) => {
          const d = pathFromCoords(poly, true);
          if(d) out += `<path d="${d}"/>`;
        });
        return out + `</g>`;
      },
      water: () => {
        if(!state.osmData || !state.mapFeatures.waterAreas.enabled || !state.osmData.waterPolygons.length) return '';
        let out = `<g id="waterAreas" fill="${state.mapFeatures.waterAreas.color}" fill-opacity="${toUnitOpacity(state.mapFeatures.waterAreas.opacity)}">`;
        state.osmData.waterPolygons.forEach((poly) => {
          const d = pathFromCoords(poly, true);
          if(d) out += `<path d="${d}"/>`;
        });
        return out + `</g>`;
      },
      rivers: () => {
        if(!state.osmData || !state.mapFeatures.rivers.enabled || !state.osmData.waterLines.length) return '';
        let out = `<g id="rivers" stroke="${state.mapFeatures.rivers.color}" stroke-width="${state.mapFeatures.rivers.width}" stroke-opacity="${toUnitOpacity(state.mapFeatures.rivers.opacity)}" fill="none" stroke-linecap="round" stroke-linejoin="round">`;
        state.osmData.waterLines.forEach((line) => {
          const d = pathFromCoords(line, false);
          if(d) out += `<path d="${d}"/>`;
        });
        return out + `</g>`;
      },
      roads: () => {
        if(!state.osmData || !state.mapFeatures.roads.enabled || !state.osmData.roadLines.length) return '';
        let out = `<g id="roads" stroke="${state.mapFeatures.roads.color}" stroke-width="${state.mapFeatures.roads.width}" stroke-opacity="${toUnitOpacity(state.mapFeatures.roads.opacity)}" fill="none" stroke-linecap="round" stroke-linejoin="round">`;
        state.osmData.roadLines.forEach((line) => {
          const d = pathFromCoords(line, false);
          if(d) out += `<path d="${d}"/>`;
        });
        return out + `</g>`;
      },
      contours: () => {
        state.contourPaths = [];
        if(!state.contour.enabled) return '';
        if(!state.terrainData || state.terrainData.delta <= 0) {
          const cx = wMm / 2;
          const cy = hMm / 2;
          return `<text x="${cx}" y="${cy}" text-anchor="middle" font-family="SF Pro Text, Segoe UI, Roboto, sans-serif" font-size="6" fill="#9AA3B2">Elevation data missing. Try generating again.</text>`;
        }
        const levels = getContourLevels();
        let out = `<g id="contours" stroke="${state.contour.color}" stroke-width="${state.contour.width}" stroke-opacity="${toUnitOpacity(state.contour.opacity)}" fill="none" stroke-linecap="round" stroke-linejoin="round">`;
        levels.forEach(level => {
          const segments = getContourSegments(level, wMm, hMm);
          if(!segments.length) return;
          const polylines = buildPolylines(segments);
          polylines.forEach(line => {
            const smoothed = state.contour.smooth ? smoothPolyline(line, state.contour.smooth) : line;
            if(smoothed.length < 2) return;
            state.contourPaths.push(smoothed);
            const path = smoothed.map((pt, idx) => `${idx ? 'L' : 'M'} ${pt[0].toFixed(2)} ${pt[1].toFixed(2)}`).join(' ');
            out += `<path d="${path}" />`;
          });
        });
        return out + `</g>`;
      },
      labels: () => {
        if(!state.osmData || !state.mapFeatures.labels.enabled || !state.osmData.places.length) return '';
        const fontFamilies = {
          system: 'SF Pro Text, Segoe UI, Roboto, sans-serif',
          serif: 'Georgia, Times New Roman, serif',
          mono: 'SF Mono, Menlo, Consolas, monospace'
        };
        const fontFamily = fontFamilies[state.mapFeatures.labels.font] || fontFamilies.system;
        const halo = state.theme.background;
        let out = `<g id="placeLabels" font-family="${fontFamily}" font-size="${state.mapFeatures.labels.size}mm" text-anchor="middle" fill="${state.mapFeatures.labels.color}" fill-opacity="${toUnitOpacity(state.mapFeatures.labels.opacity)}" paint-order="stroke">`;
        state.osmData.places.forEach((place) => {
          const [x, y] = projectToSvg(place.lat, place.lon);
          out += `<text x="${x.toFixed(2)}" y="${y.toFixed(2)}" stroke="${halo}" stroke-width="0.6">${place.name}</text>`;
        });
        return out + `</g>`;
      }
    };

    state.layerOrder.slice().reverse().forEach((key) => {
      if(layers[key]) {
        svg += layers[key]();
      }
    });

    svg += `</g>`;
    if(includeFrame) {
      svg += `<rect x="0.5" y="0.5" width="${wMm - 1}" height="${hMm - 1}" fill="none" stroke="rgba(36,48,65,0.6)" stroke-width="0.5" />`;
    }
    svg += `</svg>`;
    return svg;
  }

  function renderSVG() {
    const svg = buildSvgMarkup({ includeBackground: true, includeGradient: true, includeFrame: true });
    $('previewArea').innerHTML = svg;
    updatePngRangeInfo();
    state.previewDirty = false;
    updateRefreshButton();
  }

  const polygonArea = (poly) => {
    let sum = 0;
    for(let i = 0; i < poly.length - 1; i++) {
      sum += poly[i][0] * poly[i + 1][1] - poly[i + 1][0] * poly[i][1];
    }
    return sum / 2;
  };

  const getClipPolygon = () => {
    const w = state.wMm;
    const h = state.hMm;
    if(['rect','din_l','din_p','sq'].includes(state.shape)) {
      return [[0,0],[w,0],[w,h],[0,h]];
    }
    if(state.shape === 'hex') {
      const r = w / 2;
      const cx = w / 2;
      const cy = h / 2;
      const pts = [];
      for(let i=0; i<6; i++) {
        const a = i * Math.PI / 3 - Math.PI / 6;
        pts.push([cx + r * Math.cos(a), cy + r * Math.sin(a)]);
      }
      return pts;
    }
    if(state.shape === 'circle') {
      const r = w / 2;
      const cx = w / 2;
      const cy = h / 2;
      const pts = [];
      const steps = 48;
      for(let i=0; i<steps; i++) {
        const a = (i / steps) * Math.PI * 2;
        pts.push([cx + r * Math.cos(a), cy + r * Math.sin(a)]);
      }
      return pts;
    }
    return [[0,0],[w,0],[w,h],[0,h]];
  };

  const clipPolygon = (subject, clip) => {
    let output = subject.slice();
    const isInside = (pt, edgeStart, edgeEnd) => {
      return (edgeEnd[0] - edgeStart[0]) * (pt[1] - edgeStart[1]) - (edgeEnd[1] - edgeStart[1]) * (pt[0] - edgeStart[0]) >= 0;
    };
    const lineIntersection = (s, e, cp1, cp2) => {
      const dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
      const dp = [s[0] - e[0], s[1] - e[1]];
      const n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0];
      const n2 = s[0] * e[1] - s[1] * e[0];
      const denom = dc[0] * dp[1] - dc[1] * dp[0];
      if(Math.abs(denom) < 1e-9) return e;
      return [
        (n1 * dp[0] - n2 * dc[0]) / denom,
        (n1 * dp[1] - n2 * dc[1]) / denom
      ];
    };
    for(let i=0; i<clip.length; i++) {
      const cp1 = clip[i];
      const cp2 = clip[(i + 1) % clip.length];
      const input = output.slice();
      output = [];
      if(!input.length) break;
      let s = input[input.length - 1];
      input.forEach((e) => {
        if(isInside(e, cp1, cp2)) {
          if(!isInside(s, cp1, cp2)) {
            output.push(lineIntersection(s, e, cp1, cp2));
          }
          output.push(e);
        } else if(isInside(s, cp1, cp2)) {
          output.push(lineIntersection(s, e, cp1, cp2));
        }
        s = e;
      });
    }
    return output;
  };

  const clipSegmentToConvex = (p0, p1, clip) => {
    let t0 = 0;
    let t1 = 1;
    for(let i=0; i<clip.length; i++) {
      const a = clip[i];
      const b = clip[(i + 1) % clip.length];
      const edge = [b[0] - a[0], b[1] - a[1]];
      const normal = [edge[1], -edge[0]];
      const w = [p0[0] - a[0], p0[1] - a[1]];
      const denom = normal[0] * (p1[0] - p0[0]) + normal[1] * (p1[1] - p0[1]);
      const numer = -(normal[0] * w[0] + normal[1] * w[1]);
      if(Math.abs(denom) < 1e-9) {
        if(numer < 0) return null;
        continue;
      }
      const t = numer / denom;
      if(denom < 0) {
        t0 = Math.max(t0, t);
      } else {
        t1 = Math.min(t1, t);
      }
      if(t0 > t1) return null;
    }
    const c0 = [p0[0] + (p1[0] - p0[0]) * t0, p0[1] + (p1[1] - p0[1]) * t0];
    const c1 = [p0[0] + (p1[0] - p0[0]) * t1, p0[1] + (p1[1] - p0[1]) * t1];
    return [c0, c1];
  };

  const clipPolylineToPolygon = (line, clip) => {
    if(line.length < 2) return [];
    const out = [];
    let current = [];
    for(let i=0; i<line.length - 1; i++) {
      const clipped = clipSegmentToConvex(line[i], line[i + 1], clip);
      if(clipped) {
        const [c0, c1] = clipped;
        if(!current.length) {
          current.push(c0, c1);
        } else {
          const last = current[current.length - 1];
          if(Math.hypot(last[0] - c0[0], last[1] - c0[1]) > 1e-4) {
            out.push(current);
            current = [c0, c1];
          } else {
            current.push(c1);
          }
        }
      } else if(current.length) {
        out.push(current);
        current = [];
      }
    }
    if(current.length) out.push(current);
    return out;
  };

  const ensureClosed = (poly) => {
    if(poly.length < 3) return poly;
    const first = poly[0];
    const last = poly[poly.length - 1];
    if(Math.hypot(first[0] - last[0], first[1] - last[1]) > 1e-4) {
      return poly.concat([first]);
    }
    return poly;
  };

  $('btnDXF').onclick = () => {
    let dxf = "0\nSECTION\n2\nHEADER\n0\nENDSEC\n0\nSECTION\n2\nENTITIES\n";
    const rgbToAci = ({ r, g, b }) => {
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      if(max < 40) return 7;
      if(max - min < 20 && max > 200) return 7;
      if(r >= g && r >= b) {
        if(g > 200 && b < 120) return 2;
        if(b > 200 && g < 120) return 6;
        return 1;
      }
      if(g >= r && g >= b) {
        if(b > 200) return 4;
        return 3;
      }
      if(b >= r && b >= g) return 5;
      return 7;
    };
    const writePolyline = (layer, pts, color, forceClosed = null) => {
      if(pts.length < 2) return;
      const first = pts[0];
      const last = pts[pts.length - 1];
      const closed = forceClosed ?? (Math.hypot(first[0] - last[0], first[1] - last[1]) < 0.01);
      const outPts = closed ? pts.slice(0, -1) : pts;
      const rgb = colorToRgb(color);
      const aci = rgbToAci(rgb);
      const trueColor = (rgb.r << 16) + (rgb.g << 8) + rgb.b;
      dxf += `0\nLWPOLYLINE\n8\n${layer}\n62\n${aci}\n420\n${trueColor}\n90\n${outPts.length}\n70\n${closed ? 1 : 0}\n`;
      outPts.forEach(p => dxf += `10\n${p[0].toFixed(4)}\n20\n${(state.hMm - p[1]).toFixed(4)}\n`);
    };
    const writeText = (layer, text, x, y, height, color) => {
      if(!text) return;
      const rgb = colorToRgb(color);
      const aci = rgbToAci(rgb);
      const trueColor = (rgb.r << 16) + (rgb.g << 8) + rgb.b;
      const safeText = String(text).replace(/[\r\n\t]+/g, ' ').trim();
      if(!safeText) return;
      dxf += `0\nTEXT\n8\n${layer}\n62\n${aci}\n420\n${trueColor}\n10\n${x.toFixed(4)}\n20\n${(state.hMm - y).toFixed(4)}\n40\n${height.toFixed(4)}\n1\n${safeText}\n50\n0\n`;
    };
    if(!state.contourPaths.length) {
      alert('Generate contours first.');
      return;
    }
    const clipPoly = getClipPolygon();
    if(polygonArea(clipPoly) < 0) clipPoly.reverse();
    if(state.contour.enabled) {
      state.contourPaths.forEach(path => {
        clipPolylineToPolygon(path, clipPoly).forEach(seg => writePolyline('CONTOURS', seg, state.contour.color, false));
      });
    }
    if(state.osmData) {
      if(state.mapFeatures.greenAreas.enabled) {
        state.osmData.greenPolygons.forEach(poly => {
          const clipped = clipPolygon(poly, clipPoly);
          if(clipped.length >= 3) writePolyline('GREEN_AREAS', ensureClosed(clipped), state.mapFeatures.greenAreas.color, true);
        });
      }
      if(state.mapFeatures.waterAreas.enabled) {
        state.osmData.waterPolygons.forEach(poly => {
          const clipped = clipPolygon(poly, clipPoly);
          if(clipped.length >= 3) writePolyline('WATER_AREAS', ensureClosed(clipped), state.mapFeatures.waterAreas.color, true);
        });
      }
      if(state.mapFeatures.rivers.enabled) {
        state.osmData.waterLines.forEach(line => {
          clipPolylineToPolygon(line, clipPoly).forEach(seg => writePolyline('RIVERS', seg, state.mapFeatures.rivers.color, false));
        });
      }
      if(state.mapFeatures.roads.enabled) {
        state.osmData.roadLines.forEach(line => {
          clipPolylineToPolygon(line, clipPoly).forEach(seg => writePolyline('ROADS', seg, state.mapFeatures.roads.color, false));
        });
      }
      if(state.mapFeatures.labels.enabled && state.osmData.places?.length) {
        state.osmData.places.forEach((place) => {
          const [x, y] = projectToSvg(place.lat, place.lon);
          const inside = clipPolygon([[x, y], [x + 0.01, y], [x + 0.01, y + 0.01]], clipPoly).length;
          if(!inside) return;
          writeText('LABELS', place.name, x, y, state.mapFeatures.labels.size, state.mapFeatures.labels.color);
        });
      }
    }
    writePolyline('FRAME', ensureClosed(clipPoly), state.contour.color, true);
    dxf += "0\nENDSEC\n0\nEOF";
    save(new Blob([dxf], {type:'application/dxf'}), 'Topomapper.dxf');
  };

  function findBandIndex(value, boundaries) {
    if(value <= boundaries[0]) return 0;
    if(value >= boundaries[boundaries.length - 1]) return boundaries.length - 2;
    let lo = 0;
    let hi = boundaries.length - 2;
    while(lo <= hi) {
      const mid = Math.floor((lo + hi) / 2);
      if(value < boundaries[mid]) {
        hi = mid - 1;
      } else if(value >= boundaries[mid + 1]) {
        lo = mid + 1;
      } else {
        return mid;
      }
    }
    return Math.max(0, Math.min(boundaries.length - 2, lo));
  }

  function drawSvgOnCanvas(ctx, svgMarkup, w, h) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        ctx.drawImage(img, 0, 0, w, h);
        resolve();
      };
      img.onerror = reject;
      img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgMarkup)));
    });
  }

  function exportLayeredPng() {
    if(!state.terrainData) {
      alert('Generate contours first.');
      return;
    }
    const alpha = Math.round(255 * clamp(toUnitOpacity(state.png.gradientOpacity), 0, 1));
    const e = +$('pngResRange').value;
    const r = state.hMm / state.wMm;
    const w = state.wMm >= state.hMm ? e : Math.round(e / r);
    const h = state.wMm >= state.hMm ? Math.round(e * r) : e;
    const cv = document.createElement('canvas');
    cv.width = w;
    cv.height = h;
    const ctx = cv.getContext('2d');
    ctx.fillStyle = state.theme.background;
    ctx.fillRect(0, 0, w, h);

    const range = getShapeHeightRange();
    if(!range) {
      alert('Elevation data missing.');
      return;
    }
    const boundaries = [range.minNorm, ...getContourLevels(range.minNorm, range.maxNorm), range.maxNorm];
    if(boundaries.length < 2) {
      alert('Contour range too small for height band export.');
      return;
    }
    const bandCount = Math.max(2, boundaries.length - 1);
    const bandColors = [];
    for(let i=0; i<boundaries.length - 1; i++) {
      const midNorm = (boundaries[i] + boundaries[i + 1]) / 2;
      const height = state.terrainData.min + midNorm;
      const t = range.maxZ === range.minZ ? 0 : (height - range.minZ) / (range.maxZ - range.minZ);
      bandColors.push(getHypsometricBandColor(t, state.png.scheme, bandCount));
    }

    const imgData = ctx.createImageData(w, h);
    const data = imgData.data;
    const step = 1 / Math.max(state.terrainData.cols - 1, state.terrainData.rows - 1);
    for(let y=0; y<h; y++) {
      const ny = h === 1 ? 0 : y / (h - 1);
      for(let x=0; x<w; x++) {
        const nx = w === 1 ? 0 : x / (w - 1);
        const zNorm = getZInterpolated(nx, ny);
        const band = findBandIndex(zNorm, boundaries);
        const height = state.terrainData.min + zNorm;
        const elevationT = range.maxZ === range.minZ ? 0 : (height - range.minZ) / (range.maxZ - range.minZ);
        const shade = getHillshade(nx, ny, step, zNorm);
        const color = applyReliefOverlay(bandColors[band], shade, elevationT);
        const idx = (y * w + x) * 4;
        data[idx] = color.r;
        data[idx + 1] = color.g;
        data[idx + 2] = color.b;
        data[idx + 3] = alpha;
      }
    }
    ctx.putImageData(imgData, 0, 0);
    const overlaySvg = buildSvgMarkup({ includeBackground: false, includeGradient: false, includeFrame: true });
    drawSvgOnCanvas(ctx, overlaySvg, w, h)
      .then(() => cv.toBlob(b => save(b, 'Topomapper_Layered.png')))
      .catch(() => cv.toBlob(b => save(b, 'Topomapper_Layered.png')));
  }

  $('btnPNG').onclick = () => {
    if(state.png.layered) {
      exportLayeredPng();
      return;
    }
    const e = +$('pngResRange').value, r = state.hMm/state.wMm;
    const w = state.wMm >= state.hMm ? e : Math.round(e/r), h = state.wMm >= state.hMm ? Math.round(e*r) : e;
    const s = new XMLSerializer().serializeToString($('prevSvg'));
    const img = new Image(), cv = document.createElement('canvas'); cv.width = w; cv.height = h;
    img.onload = () => { const ctx = cv.getContext('2d'); ctx.fillStyle=state.theme.background; ctx.fillRect(0,0,w,h); ctx.drawImage(img,0,0,w,h); cv.toBlob(b => save(b, 'Topomapper.png')); };
    img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(s)));
  };

  $('btn3MF').onclick = async () => {
    if(!state.terrainData) {
      alert('Generate contours first.');
      return;
    }
    msg('Generating Assembly...'); await new Promise(r=>setTimeout(r,100));
    const zip = new JSZip(), targetH = +$('targetH').value;
    let zScale = state.terrainData && state.terrainData.delta > 0 ? targetH / state.terrainData.delta : 1;
    const objs = []; let objId = 1;

    // 1. Terrain Mesh (Watertight)
    const res = 220, tm = { v:[], t:[] }, idxMap = new Map();
    const gridSize = res + 1;
    let heightGrid = new Float32Array(gridSize * gridSize);
    for(let r=0; r<=res; r++) {
      for(let c=0; c<=res; c++) {
        heightGrid[r * gridSize + c] = getZInterpolated(c / res, r / res);
      }
    }
    const meshSmoothPasses = 2;
    for(let i=0; i<meshSmoothPasses; i++) {
      heightGrid = smoothPass(heightGrid, gridSize, gridSize);
    }
    const isIn = (x,y) => { if(['rect','din_l','din_p','sq'].includes(state.shape)) return true; const dx=x-state.wMm/2, dy=y-state.hMm/2; return (dx*dx+dy*dy)<=(state.wMm/2)**2; };
    for(let r=0;r<=res;r++) for(let c=0;c<=res;c++) {
      const x=c/res*state.wMm, y=r/res*state.hMm; if(!isIn(x,y)) continue;
      const z=2.0 + (heightGrid[r * gridSize + c] * zScale);
      idxMap.set(`${r},${c}`, {t: tm.v.push([x,y,z])-1, b: tm.v.push([x,y,0])-1 });
    }
    for(let r=0;r<res;r++) for(let c=0;c<res;c++) {
      const tl=idxMap.get(`${r},${c}`), tr=idxMap.get(`${r},${c+1}`), bl=idxMap.get(`${r+1},${c}`), br=idxMap.get(`${r+1},${c+1}`);
      if(tl&&tr&&bl&&br) {
        tm.t.push([tl.t,bl.t,tr.t],[tr.t,bl.t,br.t]);
        tm.t.push([tl.b,tr.b,bl.b],[tr.b,br.b,bl.b]);
        if(!idxMap.get(`${r-1},${c}`)) tm.t.push([tl.t,tr.t,tl.b],[tl.b,tr.t,tr.b]);
        if(!idxMap.get(`${r+1},${c}`)) tm.t.push([bl.t,bl.b,br.t],[br.t,bl.b,br.b]);
        if(!idxMap.get(`${r},${c-1}`)) tm.t.push([tl.t,tl.b,bl.t],[bl.t,bl.b,tl.t]);
        if(!idxMap.get(`${r},${c+1}`)) tm.t.push([tr.t,br.t,tr.b],[tr.b,br.t,br.b]);
      }
    }
    objs.push({id:objId++, name:'Terrain', mesh:tm});

    let resXml='', buildXml='';
    objs.forEach(o => {
      let vS='', tS=''; o.mesh.v.forEach(v=> vS+=`<vertex x="${v[0].toFixed(3)}" y="${v[1].toFixed(3)}" z="${v[2].toFixed(3)}" />`);
      o.mesh.t.forEach(t=> tS+=`<triangle v1="${t[0]}" v2="${t[1]}" v3="${t[2]}" />`);
      resXml += `<object id="${o.id}" name="${o.name}" type="model"><mesh><vertices>${vS}</vertices><triangles>${tS}</triangles></mesh></object>`;
      buildXml += `<item objectid="${o.id}" />`;
    });
    const xml = `<?xml version="1.0" encoding="UTF-8"?><model unit="millimeter" xml:lang="en" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02"><resources>${resXml}</resources><build>${buildXml}</build></model>`;
    zip.file("3D/3dmodel.model", xml);
    zip.file("[Content_Types].xml", `<?xml version="1.0" encoding="UTF-8"?><Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types"><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/><Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml"/></Types>`);
    zip.folder("_rels").file(".rels", `<?xml version="1.0" encoding="UTF-8"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rel1" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" Target="3D/3dmodel.model"/></Relationships>`);
    save(await zip.generateAsync({type:"blob"}), 'Topomapper_Terrain.3mf');
    idle();
  };

  window.closeModal = () => $('modal').classList.remove('open');
  function save(b, n) { const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download=n; a.click(); }
})();
</script>
</body>
</html>
