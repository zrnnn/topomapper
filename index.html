<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Vectorcity 27.0 — Terrain Architect Studio</title>

  <!-- Libs -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <style>
    :root {
      /* Apple iOS Design tokens */
      --color-bg: #F2F2F7;
      --color-panel: rgba(255, 255, 255, 0.98);
      --color-primary: #007AFF;
      --color-primary-hover: #0056B3;
      --color-text: #1C1C1E;
      --color-text-sec: #8E8E93;
      --color-border: rgba(60, 60, 67, 0.12);
      --radius-ios: 22px;
      --sidebar-w: 400px;
      --blur: blur(40px);
    }

    * { box-sizing: border-box; outline: none; -webkit-tap-highlight-color: transparent; }

    body {
      margin: 0; font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto, sans-serif;
      background: var(--color-bg); color: var(--color-text); height: 100vh; overflow: hidden; display: flex;
    }

    /* MAP AREA */
    .viewport { position: relative; flex: 1; height: 100%; }
    #map { width: 100%; height: 100%; z-index: 0; background: #D1D1D6; }

    /* SIDEBAR (iOS Floating Panel) */
    .sidebar {
      position: absolute; top: 16px; left: 16px; bottom: 16px; width: var(--sidebar-w);
      z-index: 1000; background: var(--color-panel); backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur); border: 1px solid rgba(255,255,255,0.6);
      border-radius: var(--radius-ios); box-shadow: 0 15px 45px rgba(0,0,0,0.12);
      display: flex; flex-direction: column; overflow: hidden;
    }

    .sidebar-header {
      padding: 24px; border-bottom: 1px solid var(--color-border);
      display: flex; align-items: center; justify-content: space-between;
      background: rgba(255,255,255,0.4);
    }
    .brand { font-weight: 800; font-size: 24px; letter-spacing: -0.8px; color: var(--color-text); text-decoration: none; display: flex; align-items: center; gap: 10px; }
    .scroll-content { flex: 1; overflow-y: auto; padding: 24px; }

    /* UI GROUPS */
    .group { margin-bottom: 28px; }
    label { font-size: 11px; font-weight: 700; color: var(--color-text-sec); margin-bottom: 8px; display: block; text-transform: uppercase; letter-spacing: 0.5px; }

    input, select {
      width: 100%; padding: 12px 14px; border-radius: 12px;
      border: 1px solid transparent; background: rgba(118, 118, 128, 0.1);
      font-size: 15px; color: var(--color-text); transition: 0.2s;
    }
    input:focus, select:focus { background: #fff; border-color: var(--color-primary); box-shadow: 0 0 0 3px rgba(0,122,255,0.1); }
    .input-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }

    /* SEARCH */
    .search-container { position: relative; }
    .suggestions {
      position: absolute; top: 100%; left: 0; right: 0; background: rgba(255,255,255,0.98);
      backdrop-filter: blur(15px); border-radius: 14px; margin-top: 8px; padding: 6px; z-index: 2000;
      box-shadow: 0 10px 40px rgba(0,0,0,0.15); border: 1px solid var(--color-border); display: none;
    }
    .suggestion-item { padding: 12px; font-size: 14px; border-radius: 10px; cursor: pointer; border-bottom: 1px solid #f2f2f7; }
    .suggestion-item:hover { background: #f2f2f7; color: var(--color-primary); }

    /* LAYER LIST & CUSTOMIZER */
    .layer-list { display: flex; flex-direction: column; gap: 8px; }
    .layer-item {
      background: rgba(255,255,255,0.5); border-radius: 16px;
      border: 1px solid rgba(0,0,0,0.04); transition: 0.2s; overflow: hidden;
    }
    .layer-item.open { background: white; border-color: rgba(0,122,255,0.2); }
    .layer-head { display: flex; align-items: center; justify-content: space-between; padding: 14px 18px; cursor: pointer; }
    .layer-info { display: flex; align-items: center; gap: 10px; font-weight: 600; font-size: 15px; }
    .chevron { transition: transform 0.3s; width: 14px; height: 14px; opacity: 0.4; }
    .layer-item.open .chevron { transform: rotate(180deg); opacity: 1; color: var(--color-primary); }
    .layer-body { display: none; padding: 0 18px 18px 18px; background: white; }
    .layer-item.open .layer-body { display: block; }

    /* CUSTOMIZER CONTROLS */
    .cust-row { display: flex; align-items: center; justify-content: space-between; margin-top: 12px; gap: 10px; }
    .color-dot { width: 32px; height: 32px; border-radius: 50%; border: 3px solid #fff; box-shadow: 0 2px 6px rgba(0,0,0,0.1); position: relative; overflow: hidden; cursor: pointer; }
    .color-dot input { position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; opacity: 0; cursor: pointer; }
    input[type=range] { flex: 1; height: 4px; border-radius: 2px; background: #d1d1d6; -webkit-appearance: none; }
    input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #fff; box-shadow: 0 2px 6px rgba(0,0,0,0.15); border: 0.5px solid #eee; }

    /* IOS SWITCH */
    .ios-switch {
      position: relative; width: 44px; height: 26px;
      background: #E9E9EA; border-radius: 20px; cursor: pointer; transition: 0.3s;
    }
    .ios-switch::after {
      content: ''; position: absolute; top: 2px; left: 2px;
      width: 22px; height: 22px; background: #fff; border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0,0,0,0.15); transition: 0.3s cubic-bezier(0.3, 1.5, 0.7, 1);
    }
    .ios-switch.on { background: #34C759; }
    .ios-switch.on::after { transform: translateX(18px); }

    /* BUTTONS */
    .btn-main {
      width: 100%; padding: 18px; border-radius: 16px; border: none;
      font-weight: 700; font-size: 17px; cursor: pointer; transition: 0.2s;
      background: var(--color-primary); color: #fff; box-shadow: 0 10px 20px rgba(0,122,255,0.25);
    }
    .btn-main:hover { transform: translateY(-2px); background: var(--color-primary-hover); }

    /* VIEWFINDER Overlay */
    .viewfinder-wrapper { position: absolute; inset: 0; pointer-events: none; z-index: 500; }
    .vf-mask { fill: rgba(0,0,0,0.35); }
    .vf-stroke { fill: none; stroke: #fff; stroke-width: 2.5; filter: drop-shadow(0 0 5px rgba(0,0,0,0.4)); }
    .vf-badge {
      position: absolute;
      transform: translate(-50%, -50%); /* Centered on the bottom line */
      background: var(--color-primary);
      color: #fff; padding: 8px 16px;
      border-radius: 20px; font-size: 12px; font-weight: 700; white-space: nowrap;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      pointer-events: auto;
    }

    /* MODAL SHEETS */
    .modal-overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.4); backdrop-filter: blur(10px);
      z-index: 2000; display: none; align-items: center; justify-content: center; opacity: 0; transition: 0.3s;
    }
    .modal-overlay.open { display: flex; opacity: 1; }
    .modal-card {
      width: 95vw; height: 92vh; background: #fff; border-radius: 32px;
      display: flex; overflow: hidden; box-shadow: 0 40px 100px rgba(0,0,0,0.3);
    }
    .preview-stage { flex: 1; background: #F2F2F7; display: flex; align-items: center; justify-content: center; padding: 40px; overflow: auto; }
    .export-side { width: 400px; background: #fff; border-left: 1px solid var(--color-border); padding: 40px; display: flex; flex-direction: column; gap: 30px; overflow-y: auto; }

    /* LOADER */
    .loader {
      position: fixed; top: 30px; left: 50%; transform: translateX(-50%);
      background: #fff; padding: 14px 28px; border-radius: 40px; z-index: 9999; display: none; align-items: center; gap: 12px;
      font-weight: 600; box-shadow: 0 10px 30px rgba(0,0,0,0.1); border: 1px solid var(--color-border);
    }
    .loader.active { display: flex; }
    .spinner { width: 20px; height: 20px; border: 3px solid #E5E5EA; border-top-color: var(--color-primary); border-radius: 50%; animation: spin 0.8s infinite linear; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>

<div id="loader" class="loader"><div class="spinner"></div><span id="loaderText">Loading...</span></div>

<div class="sidebar">
  <div class="sidebar-header">
    <a href="#" class="brand">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="var(--color-primary)"><path d="M12 2l-5.5 9h11z"/><path d="M12 22l5.5-9h-11z"/></svg>
      Vectorcity
    </a>
  </div>
  <div class="scroll-content">
    <div class="group">
      <label>Location Search</label>
      <div class="search-container">
        <input type="text" id="searchInp" placeholder="City, Region..." autocomplete="off">
        <div id="suggestionBox" class="suggestions"></div>
      </div>
    </div>

    <div class="group">
      <label>Format & Dimension</label>
      <select id="shapeSel" style="margin-bottom:12px;">
        <option value="rect">Rectangle</option>
        <option value="din_l">DIN Landscape</option>
        <option value="din_p">DIN Portrait</option>
        <option value="sq">Square</option>
        <option value="circle">Circle</option>
        <option value="hex">Hexagon</option>
      </select>
      <div class="input-grid">
        <div><label>Width (mm)</label><input type="number" id="dimW" value="200"></div>
        <div><label>Height (mm)</label><input type="number" id="dimH" value="140"></div>
      </div>
    </div>

    <div class="group">
      <label>Contour Lines</label>
      <p style="font-size:11px; color:var(--color-text-sec); margin-top:6px; line-height:1.4;">
        Elevation data is always loaded. Contour density adapts automatically for clean, non-overlapping vectors.
      </p>
    </div>

    <button id="btnGen" class="btn-main">Generate Preview</button>
    <div class="group" style="margin-top:18px;">
      <label>Offline Use</label>
      <p style="font-size:11px; color:var(--color-text-sec); margin-top:6px; line-height:1.4;">
        Save this tool as a standalone HTML file and open it directly in Chrome.
      </p>
      <button id="btnDownload" class="btn-main" style="background:#3A3A3C;">Download HTML</button>
    </div>
  </div>
</div>

<div class="viewport">
  <div id="map"></div>
  <div class="viewfinder-wrapper">
    <svg id="vfSvg" width="100%" height="100%">
      <defs><mask id="vfMask"><rect width="100%" height="100%" fill="white"/><path id="vfHole" fill="black"/></mask></defs>
      <rect width="100%" height="100%" class="vf-mask" mask="url(#vfMask)"/>
      <path id="vfOutline" class="vf-stroke" />
    </svg>
    <div id="vfBadge" class="vf-badge">200 x 140 mm</div>
  </div>
</div>

<div class="modal-overlay" id="modal">
  <div class="modal-card">
    <div class="preview-stage" id="previewArea"></div>
    <div class="export-side">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <h2 style="margin:0; font-size:24px; font-weight:800; letter-spacing:-1px;">Export</h2>
        <button onclick="closeModal()" style="border:none;background:none;font-size:32px;cursor:pointer;color:var(--color-text-sec);">&times;</button>
      </div>

      <div class="group">
        <label>3D Print (3MF Assembly)</label>
        <p style="font-size:13px; color:var(--color-text-sec); margin-bottom:12px; line-height:1.5;">
          Contour-only mode focuses on elevation lines. 3MF export is disabled.
        </p>
        <div class="input-grid">
           <div><label>Socket (mm)</label><input type="text" value="2.0" disabled></div>
           <div><label>Relief Hub</label><input type="number" id="targetH" value="10"></div>
        </div>
        <button id="btn3MF" class="btn-main" style="margin-top:10px; background:#D1D1D6; color:#000; cursor:not-allowed;" disabled>3MF Disabled</button>
      </div>

      <div class="group">
        <label>Laser / Vector (DXF)</label>
        <button id="btnDXF" class="btn-main" style="background:#3A3A3C;">Download DXF R12</button>
      </div>

      <div class="group">
        <label>Poster (PNG High-Res)</label>
        <label style="margin-top:10px; font-size:10px;">Resolution (Long Edge)</label>
        <div class="cust-row" style="margin-bottom:8px;">
          <input type="range" id="pngResRange" min="500" max="5000" step="100" value="2000">
          <span id="pngResVal" style="font-size:12px; font-weight:700; width:60px;">2000px</span>
        </div>
        <button id="btnPNG" class="btn-main" style="background:#D1D1D6; color:#000;">Save PNG</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // --- STATE ---
  const state = {
    wMm: 200, hMm: 140, shape: 'rect',
    useTerrain: false, bbox: null, geo: null, terrainData: null
  };

  const $ = id => document.getElementById(id);
  const msg = t => { $('loaderText').innerText=t; $('loader').classList.add('active'); };
  const idle = () => $('loader').classList.remove('active');

  // --- MAP & SEARCH ---
  const map = L.map('map', { zoomControl:false, preferCanvas:true }).setView([48.137, 11.575], 14);
  L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { maxZoom:19 }).addTo(map);

  let timer;
  let activeSearch = null;
  $('searchInp').addEventListener('input', (e) => {
    clearTimeout(timer);
    const val = e.target.value;
    if(val.length<3) { $('suggestionBox').style.display='none'; return; }
    timer = setTimeout(async () => {
      try {
        if(activeSearch) {
          activeSearch.abort();
        }
        activeSearch = new AbortController();
        const r = await fetch(
          `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(val)}&limit=5`,
          { signal: activeSearch.signal }
        );
        const d = await r.json();
        const box = $('suggestionBox'); box.innerHTML='';
        if(d.length) {
          d.forEach(i => {
            const div = document.createElement('div'); div.className = 'suggestion-item';
            div.innerText = i.display_name.split(',').slice(0,3).join(',');
            div.onclick = () => { map.setView([i.lat,i.lon], 14); box.style.display='none'; $('searchInp').value=div.innerText; };
            box.appendChild(div);
          });
          box.style.display='block';
        }
      } catch(e) {
        if (e.name !== 'AbortError') {
          $('suggestionBox').style.display='none';
        }
      }
    }, 400);
  });

  state.useTerrain = true;
  $('pngResRange').oninput = (e) => { $('pngResVal').innerText = e.target.value + 'px'; };

  $('shapeSel').onchange = (e) => {
    state.shape = e.target.value;
    $('dimH').disabled = ['sq','circle','hex','din_l','din_p'].includes(state.shape);
    updateVf();
  };
  ['dimW','dimH'].forEach(id => $(id).oninput = updateVf);

  function updateVf() {
    state.wMm = +$('dimW').value; state.hMm = +$('dimH').value;
    if(['sq','circle','hex'].includes(state.shape)) { state.hMm = state.wMm; $('dimH').value = state.wMm; }
    if(state.shape === 'din_l') { state.hMm = Math.round(state.wMm / 1.414); $('dimH').value = state.hMm; }
    if(state.shape === 'din_p') { state.hMm = Math.round(state.wMm * 1.414); $('dimH').value = state.hMm; }

    const winW = window.innerWidth, winH = window.innerHeight, sideW = 400;
    const availW = Math.max(0, winW - sideW - 40);
    const cx = sideW + 20 + availW / 2;
    const cy = winH / 2;
    const ratio = state.hMm / state.wMm, targetW = availW * 0.7, targetH = winH * 0.7;
    let pxW, pxH;
    if(targetW*ratio <= targetH) { pxW=targetW; pxH=pxW*ratio; } else { pxH=targetH; pxW=pxH/ratio; }
    const hw = pxW/2, hh = pxH/2;
    let d = '';
    if(['rect','din_l','din_p','sq'].includes(state.shape)) d = `M ${cx-hw},${cy-hh} H ${cx+hw} V ${cy+hh} H ${cx-hw} Z`;
    else if(state.shape === 'circle') d = `M ${cx},${cy} m -${hw},0 a ${hw},${hw} 0 1,0 ${pxW},0 a ${hw},${hw} 0 1,0 -${pxW},0`;
    else if(state.shape === 'hex') {
      const r = hw, pts = [];
      for(let i=0;i<6;i++){ const a = i*Math.PI/3 - Math.PI/6; pts.push([cx+r*Math.cos(a), cy+r*Math.sin(a)]); }
      d = `M ${pts[0][0]},${pts[0][1]} ` + pts.slice(1).map(p=>`L ${p[0]},${p[1]}`).join(' ') + ' Z';
    }
    $('vfHole').setAttribute('d', d); $('vfOutline').setAttribute('d', d);
    $('vfBadge').style.left = cx+'px';
    $('vfBadge').style.top = (cy+hh)+'px';
    $('vfBadge').innerText = `${state.wMm} × ${state.hMm} mm`;
    state.bbox = { sw: map.containerPointToLatLng([cx-hw, cy+hh]), ne: map.containerPointToLatLng([cx+hw, cy-hh]) };
  }
  window.onresize = updateVf; map.on('move zoom', updateVf); setTimeout(updateVf,500);

  // --- GENERATION PIPELINE ---
  $('btnGen').onclick = async () => {
    const {sw, ne} = state.bbox;
    msg('Loading Elevation Data...');
    await fetchTerrain(sw, ne);
    if(!state.terrainData) { idle(); alert('Terrain data unavailable. Try a smaller area.'); return; }
    msg('Generating Contours...');
    setTimeout(() => {
      try { processContours(sw, ne); idle(); $('modal').classList.add('open'); } catch(err) {
        idle(); alert("Contour processing error."); console.error(err);
      }
    }, 100);
  };

  async function fetchTerrain(sw, ne) {
    try {
      const rows=120, cols=120; const locs=[];
      const dLat = (ne.lat-sw.lat)/(rows-1), dLon = (ne.lng-sw.lng)/(cols-1);
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) locs.push({latitude:sw.lat+r*dLat, longitude:sw.lng+c*dLon});
      const chunkSize = 800;
      const elevations = [];
      for(let i=0; i<locs.length; i+=chunkSize) {
        const batch = locs.slice(i, i+chunkSize);
        const res = await fetch('https://api.open-elevation.com/api/v1/lookup', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body:JSON.stringify({locations:batch})
        });
        const j = await res.json();
        elevations.push(...j.results.map(x=>x.elevation));
      }
      let h = elevations;
      // Heavy 8-pass Smoothing
      for(let i=0; i<8; i++) h = smoothPass(h, rows, cols);
      let min=Infinity, max=-Infinity; h.forEach(v => { if(v<min) min=v; if(v>max) max=v; });
      state.terrainData = { rows, cols, h, min, max, delta: max-min };
    } catch(e) { state.terrainData = null; }
  }

  function smoothPass(data, rows, cols) {
    const out = new Float32Array(data.length);
    for(let r=0; r<rows; r++) for(let c=0; c<cols; c++) {
      let sum=0, wSum=0;
      for(let rr=r-1; rr<=r+1; rr++) for(let cc=c-1; cc<=c+1; cc++) {
        if(rr>=0 && rr<rows && cc>=0 && cc<cols) {
          const w = (rr===r && cc===c) ? 8 : 1; sum+=data[rr*cols+cc]*w; wSum+=w;
        }
      }
      out[r*cols+c] = sum/wSum;
    }
    return out;
  }

  function processContours(sw, ne) {
    const {wMm, hMm} = state;
    const T = state.terrainData;
    if(!T || T.delta <= 0) {
      state.geo = { contours: [] };
      renderSVG();
      return;
    }
    const dLat = (ne.lat - sw.lat) / (T.rows - 1);
    const dLon = (ne.lng - sw.lng) / (T.cols - 1);
    const features = [];

    for(let r=0; r<T.rows; r++) {
      for(let c=0; c<T.cols; c++) {
        const i = r * T.cols + c;
        const lat = sw.lat + r * dLat;
        const lon = sw.lng + c * dLon;
        features.push(turf.point([lon, lat], { elevation: T.h[i] }));
      }
    }

    const sizeRef = Math.min(wMm, hMm);
    const targetLines = Math.max(8, Math.min(28, Math.round(sizeRef / 9)));
    const step = T.delta / targetLines;
    const breaks = [];
    for(let v = T.min + step; v < T.max; v += step) breaks.push(v);

    let contours = turf.isolines(turf.featureCollection(features), breaks, { zProperty: 'elevation' });
    const tolerance = Math.max(Math.abs(dLat), Math.abs(dLon)) * 1.5;
    contours = turf.simplify(contours, { tolerance, highQuality: true });
    const proj = (lon,lat) => [(lon-sw.lng)/(ne.lng-sw.lng)*wMm, hMm - ((lat-sw.lat)/(ne.lat-sw.lat)*hMm)];

    const lines = [];
    contours.features.forEach(f => {
      if(!f.geometry) return;
      if(f.geometry.type === 'MultiLineString') {
        f.geometry.coordinates.forEach(line => {
          const pts = line.map(([lon, lat]) => proj(lon, lat));
          if(pts.length > 3) lines.push({ pts });
        });
      } else if(f.geometry.type === 'LineString') {
        const pts = f.geometry.coordinates.map(([lon, lat]) => proj(lon, lat));
        if(pts.length > 3) lines.push({ pts });
      }
    });

    state.geo = { contours: lines };
    renderSVG();
  }

  function renderSVG() {
    const {wMm, hMm} = state;
    let svg = `<svg id="prevSvg" width="${wMm}mm" height="${hMm}mm" viewBox="0 0 ${wMm} ${hMm}" xmlns="http://www.w3.org/2000/svg">`;
    svg += `<rect width="100%" height="100%" fill="#fff"/>`;
    svg += `<rect x="0.5" y="0.5" width="${wMm - 1}" height="${hMm - 1}" fill="none" stroke="#E5E5EA" stroke-width="0.5" />`;

    const lines = state.geo?.contours || [];
    if(lines.length) {
      svg += `<g id="contours" stroke="#2C2C2E" stroke-width="0.25" fill="none" stroke-linecap="round" stroke-linejoin="round">`;
      lines.forEach(o => {
        if(!o.pts || o.pts.length < 2) return;
        const d = `M ${o.pts.map(p=>p[0].toFixed(1)+' '+p[1].toFixed(1)).join(' L ')}`;
        svg += `<path d="${d}"/>`;
      });
      svg += `</g>`;
    } else {
      const cx = wMm / 2;
      const cy = hMm / 2;
      svg += `<text x="${cx}" y="${cy}" text-anchor="middle" font-family="SF Pro Text, Segoe UI, Roboto, sans-serif" font-size="6" fill="#8E8E93">No contour data. Try a smaller area.</text>`;
    }
    svg += `</svg>`;
    $('previewArea').innerHTML = svg;
  }

  $('btnDXF').onclick = () => {
    let dxf = "0\nSECTION\n2\nHEADER\n0\nENDSEC\n0\nSECTION\n2\nENTITIES\n";
    const writeP = (l, pts, aci) => {
      dxf += `0\nLWPOLYLINE\n8\n${l}\n62\n${aci}\n90\n${pts.length}\n70\n1\n`;
      pts.forEach(p => dxf += `10\n${p[0].toFixed(4)}\n20\n${(state.hMm - p[1]).toFixed(4)}\n`);
    };
    (state.geo?.contours || []).forEach(o => writeP('CONTOURS', o.pts, 7));
    writeP('FRAME', [[0,0],[state.wMm,0],[state.wMm,state.hMm],[0,state.hMm],[0,0]], 6);
    dxf += "0\nENDSEC\n0\nEOF";
    save(new Blob([dxf], {type:'application/dxf'}), 'Vectorcity.dxf');
  };

  $('btnPNG').onclick = () => {
    const e = +$('pngResRange').value, r = state.hMm/state.wMm;
    const w = state.wMm >= state.hMm ? e : Math.round(e/r), h = state.wMm >= state.hMm ? Math.round(e*r) : e;
    const s = new XMLSerializer().serializeToString($('prevSvg'));
    const img = new Image(), cv = document.createElement('canvas'); cv.width = w; cv.height = h;
    img.onload = () => { const ctx = cv.getContext('2d'); ctx.fillStyle='#fff'; ctx.fillRect(0,0,w,h); ctx.drawImage(img,0,0,w,h); cv.toBlob(b => save(b, 'Vectorcity.png')); };
    img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(s)));
  };


  $('btnDownload').onclick = () => {
    const html = '<!doctype html>\n' + document.documentElement.outerHTML;
    save(new Blob([html], { type: 'text/html' }), 'vectorcity.html');
  };

  window.closeModal = () => $('modal').classList.remove('open');
  function save(b, n) { const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download=n; a.click(); }
})();
</script>
</body>
</html>
