<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Topomapper</title>

  <!-- Libs -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <style>
    :root {
      /* Dark mode tokens */
      --color-bg: #0B0F14;
      --color-panel: rgba(20, 24, 32, 0.98);
      --color-primary: #4C8DFF;
      --color-primary-hover: #346FE0;
      --color-text: #F5F7FB;
      --color-text-sec: #9AA3B2;
      --color-border: rgba(255, 255, 255, 0.08);
      --radius-ios: 22px;
      --sidebar-w: 400px;
      --header-h: 72px;
      --blur: blur(40px);
    }

    * { box-sizing: border-box; outline: none; -webkit-tap-highlight-color: transparent; }

    body {
      margin: 0; font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto, sans-serif;
      background: var(--color-bg); color: var(--color-text); height: 100vh; overflow: hidden; display: flex;
    }

    /* HEADER */
    .top-header {
      position: fixed; top: 0; left: 0; right: 0; height: var(--header-h);
      display: flex; align-items: center; justify-content: space-between;
      padding: 0 28px; z-index: 1200;
      background: linear-gradient(180deg, rgba(8,11,16,0.95), rgba(8,11,16,0.55));
      border-bottom: 1px solid rgba(255,255,255,0.08); backdrop-filter: blur(12px);
    }
    .top-brand { display: flex; align-items: center; gap: 12px; font-weight: 800; font-size: 20px; letter-spacing: -0.6px; text-decoration: none; color: var(--color-text); }
    .top-badge { font-size: 12px; padding: 6px 12px; border-radius: 999px; background: rgba(76,141,255,0.18); color: var(--color-primary); border: 1px solid rgba(76,141,255,0.3); }

    /* MAP AREA */
    .viewport { position: relative; flex: 1; height: 100%; }
    #map { width: 100%; height: 100%; z-index: 0; background: #0A0D12; filter: contrast(1.25) saturate(1.2) brightness(1.08); transition: filter 0.3s ease; }

    /* SIDEBAR (iOS Floating Panel) */
    .sidebar {
      position: absolute; top: calc(var(--header-h) + 12px); left: 16px; bottom: 16px; width: var(--sidebar-w);
      z-index: 1000; background: var(--color-panel); backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur); border: 1px solid rgba(255,255,255,0.08);
      border-radius: var(--radius-ios); box-shadow: 0 20px 55px rgba(0,0,0,0.45);
      display: flex; flex-direction: column; overflow: hidden;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .sidebar:hover { transform: translateY(-2px); box-shadow: 0 26px 65px rgba(0,0,0,0.5); }

    .sidebar-header {
      padding: 24px; border-bottom: 1px solid var(--color-border);
      display: flex; align-items: center; justify-content: space-between;
      background: rgba(16, 20, 28, 0.8);
    }
    .brand { font-weight: 800; font-size: 24px; letter-spacing: -0.8px; color: var(--color-text); text-decoration: none; display: flex; align-items: center; gap: 10px; }
    .scroll-content { flex: 1; overflow-y: auto; padding: 24px; }

    /* UI GROUPS */
    .group { margin-bottom: 28px; }
    label { font-size: 11px; font-weight: 700; color: var(--color-text-sec); margin-bottom: 8px; display: block; text-transform: uppercase; letter-spacing: 0.5px; }

    input, select {
      width: 100%; padding: 12px 14px; border-radius: 12px;
      border: 1px solid transparent; background: rgba(118, 118, 128, 0.28);
      font-size: 15px; color: var(--color-text); transition: 0.2s; box-shadow: inset 0 0 0 1px rgba(255,255,255,0.04);
    }
    select option { background: #0f141c; color: var(--color-text); }
    input:focus, select:focus { background: rgba(255,255,255,0.12); border-color: var(--color-primary); box-shadow: 0 0 0 3px rgba(76,141,255,0.25); }
    input:hover, select:hover { border-color: rgba(255,255,255,0.18); }
    .input-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }

    /* SEARCH */
    .search-container { position: relative; }
    .suggestions {
      position: absolute; top: 100%; left: 0; right: 0; background: rgba(18,22,30,0.98);
      backdrop-filter: blur(15px); border-radius: 14px; margin-top: 8px; padding: 6px; z-index: 2000;
      box-shadow: 0 10px 40px rgba(0,0,0,0.45); border: 1px solid var(--color-border); display: none;
    }
    .suggestion-item { padding: 12px; font-size: 14px; border-radius: 10px; cursor: pointer; border-bottom: 1px solid rgba(255,255,255,0.06); }
    .suggestion-item:hover { background: rgba(255,255,255,0.06); color: var(--color-primary); }

    /* LAYER LIST & CUSTOMIZER */
    .layer-list { display: flex; flex-direction: column; gap: 8px; }
    .layer-item {
      background: rgba(255,255,255,0.04); border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.08); transition: 0.2s; overflow: hidden;
    }
    .layer-item:hover { border-color: rgba(255,255,255,0.18); transform: translateY(-1px); }
    .layer-item.open { background: rgba(255,255,255,0.08); border-color: rgba(76,141,255,0.5); }
    .layer-head { display: flex; align-items: center; justify-content: space-between; padding: 14px 18px; cursor: pointer; }
    .layer-info { display: flex; align-items: center; gap: 10px; font-weight: 600; font-size: 15px; }
    .chevron { transition: transform 0.3s; width: 14px; height: 14px; opacity: 0.4; }
    .layer-item.open .chevron { transform: rotate(180deg); opacity: 1; color: var(--color-primary); }
    .layer-body { display: none; padding: 0 18px 18px 18px; background: rgba(10,12,18,0.7); }
    .layer-item.open .layer-body { display: block; }

    /* CUSTOMIZER CONTROLS */
    .cust-row { display: flex; align-items: center; justify-content: space-between; margin-top: 12px; gap: 10px; }
    .color-dot { width: 32px; height: 32px; border-radius: 50%; border: 3px solid rgba(15,18,25,0.9); box-shadow: 0 2px 10px rgba(0,0,0,0.35); position: relative; overflow: hidden; cursor: pointer; }
    .color-dot input { position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; opacity: 0; cursor: pointer; }
    input[type=range] { flex: 1; height: 4px; border-radius: 2px; background: rgba(255,255,255,0.16); -webkit-appearance: none; }
    input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #F5F7FB; box-shadow: 0 2px 8px rgba(0,0,0,0.35); border: 0.5px solid rgba(0,0,0,0.3); }

    /* IOS SWITCH */
    .ios-switch {
      position: relative; width: 44px; height: 26px;
      background: rgba(255,255,255,0.18); border-radius: 20px; cursor: pointer; transition: 0.3s;
    }
    .ios-switch::after {
      content: ''; position: absolute; top: 2px; left: 2px;
      width: 22px; height: 22px; background: #F5F7FB; border-radius: 50%;
      box-shadow: 0 2px 6px rgba(0,0,0,0.45); transition: 0.3s cubic-bezier(0.3, 1.5, 0.7, 1);
    }
    .ios-switch.on { background: #34C759; }
    .ios-switch.on::after { transform: translateX(18px); }

    /* BUTTONS */
    .btn-main {
      width: 100%; padding: 18px; border-radius: 16px; border: none;
      font-weight: 700; font-size: 17px; cursor: pointer; transition: 0.2s;
      background: var(--color-primary); color: #fff; box-shadow: 0 12px 24px rgba(76,141,255,0.25);
    }
    .btn-main:hover { transform: translateY(-2px); background: var(--color-primary-hover); }
    .btn-main:active { transform: translateY(0); }

    /* VIEWFINDER Overlay */
    .viewfinder-wrapper { position: absolute; inset: 0; pointer-events: none; z-index: 500; }
    .vf-mask { fill: rgba(0,0,0,0.35); }
    .vf-stroke { fill: none; stroke: #fff; stroke-width: 2.5; filter: drop-shadow(0 0 7px rgba(0,0,0,0.6)); }
    .vf-badge {
      position: absolute;
      transform: translate(-50%, -50%); /* Centered on the bottom line */
      background: var(--color-primary);
      color: #fff; padding: 8px 16px;
      border-radius: 20px; font-size: 12px; font-weight: 700; white-space: nowrap;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      pointer-events: auto;
    }

    /* MODAL SHEETS */
    .modal-overlay {
      position: fixed; inset: 0; background: rgba(5,8,12,0.65); backdrop-filter: blur(10px);
      z-index: 2000; display: none; align-items: center; justify-content: center; opacity: 0; transition: 0.3s;
    }
    .modal-overlay.open { display: flex; opacity: 1; }
    .modal-card {
      width: 95vw; height: 92vh; background: #0F141C; border-radius: 32px;
      display: flex; overflow: hidden; box-shadow: 0 40px 120px rgba(0,0,0,0.6);
    }
    .preview-stage { flex: 1; background: #0B0F14; display: flex; align-items: center; justify-content: center; padding: 40px; overflow: auto; }
    #previewArea svg { width: auto; height: auto; max-width: 100%; max-height: 100%; }
    .export-side { width: 400px; background: #121821; border-left: 1px solid var(--color-border); padding: 40px; display: flex; flex-direction: column; gap: 30px; overflow-y: auto; }

    /* LOADER */
    .loader {
      position: fixed; top: 30px; left: 50%; transform: translateX(-50%);
      background: #121821; padding: 14px 28px; border-radius: 40px; z-index: 9999; display: none; align-items: center; gap: 12px;
      font-weight: 600; box-shadow: 0 10px 30px rgba(0,0,0,0.45); border: 1px solid var(--color-border);
    }
    .loader.active { display: flex; }
    .spinner { width: 20px; height: 20px; border: 3px solid rgba(255,255,255,0.2); border-top-color: var(--color-primary); border-radius: 50%; animation: spin 0.8s infinite linear; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>

<div id="loader" class="loader"><div class="spinner"></div><span id="loaderText">Loading...</span></div>

<header class="top-header">
  <a class="top-brand" href="#">
    <svg width="28" height="28" viewBox="0 0 24 24" fill="var(--color-primary)"><path d="M12 2l-5.5 9h11z"/><path d="M12 22l5.5-9h-11z"/></svg>
    Topomapper
  </a>
  <span class="top-badge">Live Terrain Studio</span>
</header>

<div class="sidebar">
  <div class="sidebar-header">
    <a href="#" class="brand">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="var(--color-primary)"><path d="M12 2l-5.5 9h11z"/><path d="M12 22l5.5-9h-11z"/></svg>
      Topomapper
    </a>
  </div>
  <div class="scroll-content">
    <div class="group">
      <label>Location Search</label>
      <div class="search-container">
        <input type="text" id="searchInp" placeholder="City, Region..." autocomplete="off">
        <div id="suggestionBox" class="suggestions"></div>
      </div>
    </div>

    <div class="group">
      <label>Format & Dimension</label>
      <select id="shapeSel" style="margin-bottom:12px;">
        <option value="rect">Rectangle</option>
        <option value="din_l">DIN Landscape</option>
        <option value="din_p">DIN Portrait</option>
        <option value="sq">Square</option>
        <option value="circle">Circle</option>
        <option value="hex">Hexagon</option>
      </select>
      <div class="input-grid">
        <div><label>Width (mm)</label><input type="number" id="dimW" value="200"></div>
        <div><label>Height (mm)</label><input type="number" id="dimH" value="140"></div>
      </div>
    </div>

    <div class="group">
      <label>Contour Settings</label>
      <div class="layer-item open">
        <div class="layer-head">
          <div class="layer-info">
            <svg class="chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M6 9l6 6 6-6"/></svg>
            <span>Contour Lines</span>
          </div>
        </div>
        <div class="layer-body">
          <div class="cust-row"><label style="margin:0">Color</label><div class="color-dot" style="background:#D7E3FF"><input type="color" id="contourColor" value="#D7E3FF"></div></div>
          <div class="cust-row"><label style="margin:0">Line Width</label><input type="range" id="contourWidth" min="0.05" max="0.6" step="0.05" value="0.2"><span id="contourWidthVal" style="font-size:11px;width:36px;text-align:right;">0.2</span></div>
          <div class="cust-row"><label style="margin:0">Density</label><input type="range" id="contourDensity" min="8" max="60" step="2" value="24"><span id="contourDensityVal" style="font-size:11px;width:36px;text-align:right;">24</span></div>
          <div class="cust-row"><label style="margin:0">Detail</label><input type="range" id="contourDetail" min="0.6" max="2" step="0.1" value="1"><span id="contourDetailVal" style="font-size:11px;width:36px;text-align:right;">1.0</span></div>
        </div>
      </div>
    </div>

    <div class="group">
      <label>Color Preset</label>
      <select id="presetSel" style="margin-bottom:12px;">
        <option value="dark">Dark (Negative)</option>
        <option value="bright">Bright (Positive)</option>
        <option value="custom">Custom</option>
      </select>
      <div id="customPreset" style="display:none;">
        <div class="cust-row">
          <label style="margin:0">Background</label>
          <div class="color-dot" id="bgColorDot" style="background:#0B0F14"><input type="color" id="bgColorPicker" value="#0B0F14"></div>
          <input type="text" id="bgColorText" placeholder="#0B0F14 or rgb(11,15,20)" style="flex:1">
        </div>
        <div class="cust-row">
          <label style="margin:0">Contour Lines</label>
          <div class="color-dot" id="lineColorDot" style="background:#D7E3FF"><input type="color" id="lineColorPicker" value="#D7E3FF"></div>
          <input type="text" id="lineColorText" placeholder="#D7E3FF or rgb(215,227,255)" style="flex:1">
        </div>
      </div>
    </div>

    <div class="group">
      <div class="layer-item" style="padding: 10px 14px; display:flex; justify-content:space-between; align-items:center;">
        <span style="font-weight:600; font-size:14px;">Auto-Scale Contours</span>
        <div class="ios-switch on" id="autoScaleToggle"></div>
      </div>
      <p style="font-size:11px; color:var(--color-text-sec); margin-top:8px;">Keeps line spacing readable while preserving detail.</p>
    </div>

    <button id="btnGen" class="btn-main">Generate Preview</button>
    <div class="group" style="margin-top:18px;">
      <label>Offline Use</label>
      <p style="font-size:11px; color:var(--color-text-sec); margin-top:6px; line-height:1.4;">
        Save this tool as a standalone HTML file and open it directly in Chrome.
      </p>
      <button id="btnDownload" class="btn-main" style="background:#3A3A3C;">Download HTML</button>
    </div>
  </div>
</div>

<div class="viewport">
  <div id="map"></div>
  <div class="viewfinder-wrapper">
    <svg id="vfSvg" width="100%" height="100%">
      <defs><mask id="vfMask"><rect width="100%" height="100%" fill="white"/><path id="vfHole" fill="black"/></mask></defs>
      <rect width="100%" height="100%" class="vf-mask" mask="url(#vfMask)"/>
      <path id="vfOutline" class="vf-stroke" />
    </svg>
    <div id="vfBadge" class="vf-badge">200 x 140 mm</div>
  </div>
</div>

<div class="modal-overlay" id="modal">
  <div class="modal-card">
    <div class="preview-stage" id="previewArea"></div>
    <div class="export-side">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <h2 style="margin:0; font-size:24px; font-weight:800; letter-spacing:-1px;">Export</h2>
        <button onclick="closeModal()" style="border:none;background:none;font-size:32px;cursor:pointer;color:var(--color-text-sec);">&times;</button>
      </div>

      <div class="group">
        <label>3D Print (3MF Terrain)</label>
        <p style="font-size:13px; color:var(--color-text-sec); margin-bottom:12px; line-height:1.5;">
          Creates a watertight relief mesh based on elevation data. Contours remain 2D for vector exports.
        </p>
        <div class="input-grid">
           <div><label>Socket (mm)</label><input type="text" value="2.0" disabled></div>
           <div><label>Relief Hub</label><input type="number" id="targetH" value="10"></div>
        </div>
        <button id="btn3MF" class="btn-main" style="margin-top:10px;">Download 3MF</button>
      </div>

      <div class="group">
        <label>Laser / Vector (DXF)</label>
        <button id="btnDXF" class="btn-main" style="background:#3A3A3C;">Download DXF R12</button>
      </div>

      <div class="group">
        <label>Poster (PNG High-Res)</label>
        <label style="margin-top:10px; font-size:10px;">Resolution (Long Edge)</label>
        <div class="cust-row" style="margin-bottom:8px;">
          <input type="range" id="pngResRange" min="500" max="5000" step="100" value="2000">
          <span id="pngResVal" style="font-size:12px; font-weight:700; width:60px;">2000px</span>
        </div>
        <button id="btnPNG" class="btn-main" style="background:#2B3440; color:#F5F7FB;">Save PNG</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // --- STATE ---
  const state = {
    wMm: 200, hMm: 140, shape: 'rect',
    contour: {
      density: 24,
      detail: 1,
      width: 0.2,
      color: '#D7E3FF',
      autoScale: true
    },
    theme: {
      preset: 'dark',
      background: '#0B0F14',
      line: '#D7E3FF'
    },
    bbox: null,
    terrainData: null,
    contourSegments: []
  };

  const $ = id => document.getElementById(id);
  const msg = t => { $('loaderText').innerText=t; $('loader').classList.add('active'); };
  const idle = () => $('loader').classList.remove('active');

  // --- HELPERS: SCALING & INTERPOLATION ---
  function getZInterpolated(nx, ny) {
    if(!state.terrainData) return 0;
    const T = state.terrainData;
    const rFloat = ny * (T.rows-1);
    const cFloat = nx * (T.cols-1);
    const r0 = Math.floor(rFloat), r1 = Math.min(T.rows-1, r0+1);
    const c0 = Math.floor(cFloat), c1 = Math.min(T.cols-1, c0+1);
    const dr = rFloat - r0, dc = cFloat - c0;
    const h00 = T.h[r0*T.cols+c0], h01 = T.h[r0*T.cols+c1], h10 = T.h[r1*T.cols+c0], h11 = T.h[r1*T.cols+c1];
    return (h00*(1-dr)*(1-dc) + h01*(1-dr)*dc + h10*dr*(1-dc) + h11*dr*dc);
  }

  function isInShape(x, y) {
    if(['rect','din_l','din_p','sq'].includes(state.shape)) return true;
    const dx = x - state.wMm / 2;
    const dy = y - state.hMm / 2;
    if(state.shape === 'circle') return (dx*dx + dy*dy) <= (state.wMm/2) ** 2;
    if(state.shape !== 'hex') return true;
    const qx = Math.abs(dx) / (state.wMm / 2);
    const qy = Math.abs(dy) / (state.hMm / 2);
    return qx + qy * 0.577 <= 1;
  }

  function getContourLevels() {
    if(!state.terrainData || state.terrainData.delta <= 0) return [];
    const desired = Math.max(4, Math.round(state.contour.density * state.contour.detail));
    const minSpacing = state.contour.autoScale ? Math.max(1.2, state.contour.width * 8) : 0;
    const maxLines = minSpacing ? Math.max(4, Math.floor(Math.min(state.wMm, state.hMm) / minSpacing)) : desired;
    const lineCount = Math.max(4, Math.min(desired, maxLines));
    const interval = state.terrainData.delta / lineCount;
    return Array.from({length: lineCount - 1}, (_, i) => interval * (i + 1));
  }

  function getContourSegments(level, widthMm, heightMm) {
    if(!state.terrainData) return [];
    const T = state.terrainData;
    const rows = T.rows;
    const cols = T.cols;
    const segments = [];
    const xScale = widthMm / (cols - 1);
    const yScale = heightMm / (rows - 1);
    const safeRatio = (num, den) => {
      if(den === 0) return 0.5;
      const t = num / den;
      if(!Number.isFinite(t)) return 0.5;
      return Math.max(0, Math.min(1, t));
    };

    const edgePoint = (edge, r, c, h00, h10, h11, h01) => {
      const x = c * xScale;
      const y = r * yScale;
      if(edge === 0) {
        const t = safeRatio(level - h00, h10 - h00);
        return [x + xScale * t, y];
      }
      if(edge === 1) {
        const t = safeRatio(level - h10, h11 - h10);
        return [x + xScale, y + yScale * t];
      }
      if(edge === 2) {
        const t = safeRatio(level - h11, h01 - h11);
        return [x + xScale * (1 - t), y + yScale];
      }
      const t = safeRatio(level - h01, h00 - h01);
      return [x, y + yScale * (1 - t)];
    };

    const table = {
      0: [],
      1: [[3,2]],
      2: [[2,1]],
      3: [[3,1]],
      4: [[0,1]],
      5: 'amb',
      6: [[0,2]],
      7: [[0,3]],
      8: [[0,3]],
      9: [[0,2]],
      10: 'amb',
      11: [[0,1]],
      12: [[3,1]],
      13: [[2,1]],
      14: [[3,2]],
      15: []
    };

    for(let r=0; r<rows-1; r++) {
      for(let c=0; c<cols-1; c++) {
        const h00 = T.h[r*cols + c];
        const h10 = T.h[r*cols + c + 1];
        const h01 = T.h[(r+1)*cols + c];
        const h11 = T.h[(r+1)*cols + c + 1];
        const tl = h00 >= level;
        const tr = h10 >= level;
        const br = h11 >= level;
        const bl = h01 >= level;
        const idx = (tl<<3) | (tr<<2) | (br<<1) | bl;
        if(idx === 0 || idx === 15) continue;
        const cellCenter = (h00 + h10 + h11 + h01) / 4;
        let pairs = table[idx];
        if(pairs === 'amb') {
          if(cellCenter >= level) {
            pairs = idx === 5 ? [[0,1],[2,3]] : [[0,3],[1,2]];
          } else {
            pairs = idx === 5 ? [[0,3],[1,2]] : [[0,1],[2,3]];
          }
        }
        pairs.forEach(pair => {
          const p1 = edgePoint(pair[0], r, c, h00, h10, h11, h01);
          const p2 = edgePoint(pair[1], r, c, h00, h10, h11, h01);
          if(isInShape(p1[0], p1[1]) && isInShape(p2[0], p2[1])) {
            segments.push([p1, p2]);
          }
        });
      }
    }
    return segments;
  }

  // --- MAP & SEARCH ---
  const map = L.map('map', { zoomControl:false, preferCanvas:true }).setView([48.137, 11.575], 14);
  L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { maxZoom:19 }).addTo(map);

  let timer;
  let activeSearch = null;
  $('searchInp').addEventListener('input', (e) => {
    clearTimeout(timer);
    const val = e.target.value;
    if(val.length<3) { $('suggestionBox').style.display='none'; return; }
    timer = setTimeout(async () => {
      try {
        if(activeSearch) {
          activeSearch.abort();
        }
        activeSearch = new AbortController();
        const r = await fetch(
          `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(val)}&limit=5`,
          { signal: activeSearch.signal }
        );
        const d = await r.json();
        const box = $('suggestionBox'); box.innerHTML='';
        if(d.length) {
          d.forEach(i => {
            const div = document.createElement('div'); div.className = 'suggestion-item';
            div.innerText = i.display_name.split(',').slice(0,3).join(',');
            div.onclick = () => { map.setView([i.lat,i.lon], 14); box.style.display='none'; $('searchInp').value=div.innerText; };
            box.appendChild(div);
          });
          box.style.display='block';
        }
      } catch(e) {
        if (e.name !== 'AbortError') {
          $('suggestionBox').style.display='none';
        }
      }
    }, 400);
  });

  // --- UI CONSTRUCTION ---
  document.querySelector('.layer-head').onclick = (e) => {
    const item = e.currentTarget.closest('.layer-item');
    item.classList.toggle('open');
  };

  const presets = {
    dark: { background: '#0B0F14', line: '#D7E3FF' },
    bright: { background: '#F5F2EB', line: '#10141B' }
  };

  const parseColorInput = (value) => {
    const v = value.trim();
    if(!v) return null;
    const tester = new Option().style;
    tester.color = v;
    return tester.color ? tester.color : null;
  };

  const rgbToHex = (rgb) => {
    const match = rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
    if(!match) return null;
    const toHex = (n) => n.toString(16).padStart(2, '0');
    return `#${toHex(parseInt(match[1], 10))}${toHex(parseInt(match[2], 10))}${toHex(parseInt(match[3], 10))}`.toUpperCase();
  };

  const applyTheme = () => {
    $('previewArea').style.background = state.theme.background;
    state.contour.color = state.theme.line;
    $('contourColor').value = state.contour.color;
    $('contourColor').parentElement.style.background = state.contour.color;
    if(state.terrainData) renderSVG();
  };

  const syncCustomField = (value, pickerId, textId, dotId) => {
    const parsed = parseColorInput(value);
    if(!parsed) return;
    const hex = parsed.startsWith('rgb') ? rgbToHex(parsed) : parsed;
    if(hex) $(pickerId).value = hex;
    $(textId).value = value;
    $(dotId).style.background = parsed;
  };

  $('presetSel').onchange = (e) => {
    const preset = e.target.value;
    state.theme.preset = preset;
    $('customPreset').style.display = preset === 'custom' ? 'block' : 'none';
    if(preset === 'custom') {
      state.theme.background = $('bgColorPicker').value;
      state.theme.line = $('lineColorPicker').value;
    } else {
      state.theme.background = presets[preset].background;
      state.theme.line = presets[preset].line;
    }
    applyTheme();
  };

  $('bgColorPicker').oninput = (e) => {
    state.theme.background = e.target.value;
    $('bgColorDot').style.background = state.theme.background;
    $('bgColorText').value = state.theme.background;
    if(state.theme.preset === 'custom') applyTheme();
  };
  $('lineColorPicker').oninput = (e) => {
    state.theme.line = e.target.value;
    $('lineColorDot').style.background = state.theme.line;
    $('lineColorText').value = state.theme.line;
    if(state.theme.preset === 'custom') applyTheme();
  };
  $('bgColorText').onchange = (e) => {
    const parsed = parseColorInput(e.target.value);
    if(!parsed) return;
    state.theme.background = parsed.startsWith('rgb') ? parsed : e.target.value;
    syncCustomField(parsed, 'bgColorPicker', 'bgColorText', 'bgColorDot');
    if(state.theme.preset === 'custom') applyTheme();
  };
  $('lineColorText').onchange = (e) => {
    const parsed = parseColorInput(e.target.value);
    if(!parsed) return;
    state.theme.line = parsed.startsWith('rgb') ? parsed : e.target.value;
    syncCustomField(parsed, 'lineColorPicker', 'lineColorText', 'lineColorDot');
    if(state.theme.preset === 'custom') applyTheme();
  };

  $('contourColor').oninput = (e) => {
    state.contour.color = e.target.value;
    e.target.parentElement.style.background = state.contour.color;
    if(state.theme.preset === 'custom') {
      state.theme.line = state.contour.color;
      $('lineColorPicker').value = state.contour.color;
      $('lineColorText').value = state.contour.color;
      $('lineColorDot').style.background = state.contour.color;
    }
    if(state.terrainData) renderSVG();
  };

  $('contourWidth').oninput = (e) => {
    state.contour.width = parseFloat(e.target.value);
    $('contourWidthVal').innerText = state.contour.width.toFixed(2).replace(/\.00$/, '');
    if(state.terrainData) renderSVG();
  };

  $('contourDensity').oninput = (e) => {
    state.contour.density = parseInt(e.target.value, 10);
    $('contourDensityVal').innerText = state.contour.density;
    if(state.terrainData) renderSVG();
  };

  $('contourDetail').oninput = (e) => {
    state.contour.detail = parseFloat(e.target.value);
    $('contourDetailVal').innerText = state.contour.detail.toFixed(1);
    if(state.terrainData) renderSVG();
  };

  $('autoScaleToggle').onclick = function() { state.contour.autoScale = !state.contour.autoScale; this.classList.toggle('on'); if(state.terrainData) renderSVG(); };
  $('pngResRange').oninput = (e) => { $('pngResVal').innerText = e.target.value + 'px'; };

  $('shapeSel').onchange = (e) => {
    state.shape = e.target.value;
    $('dimH').disabled = ['sq','circle','hex','din_l','din_p'].includes(state.shape);
    updateVf();
  };
  ['dimW','dimH'].forEach(id => $(id).oninput = updateVf);

  $('presetSel').value = state.theme.preset;
  $('bgColorText').value = state.theme.background;
  $('lineColorText').value = state.theme.line;
  $('bgColorDot').style.background = state.theme.background;
  $('lineColorDot').style.background = state.theme.line;
  $('customPreset').style.display = state.theme.preset === 'custom' ? 'block' : 'none';
  applyTheme();

  function updateVf() {
    state.wMm = +$('dimW').value; state.hMm = +$('dimH').value;
    if(['sq','circle','hex'].includes(state.shape)) { state.hMm = state.wMm; $('dimH').value = state.wMm; }
    if(state.shape === 'din_l') { state.hMm = Math.round(state.wMm / 1.414); $('dimH').value = state.hMm; }
    if(state.shape === 'din_p') { state.hMm = Math.round(state.wMm * 1.414); $('dimH').value = state.hMm; }

    const winW = window.innerWidth, winH = window.innerHeight;
    const sideW = document.querySelector('.sidebar')?.offsetWidth || 400;
    const headerH = document.querySelector('.top-header')?.offsetHeight || 0;
    const pad = 24;
    const availW = Math.max(0, winW - sideW - pad * 2);
    const availH = Math.max(0, winH - headerH - pad * 2);
    const cx = sideW + pad + availW / 2;
    const cy = headerH + pad + availH / 2;
    const ratio = state.hMm / state.wMm;
    const targetW = availW * 0.78, targetH = availH * 0.78;
    let pxW, pxH;
    if(targetW*ratio <= targetH) { pxW=targetW; pxH=pxW*ratio; } else { pxH=targetH; pxW=pxH/ratio; }
    const hw = pxW/2, hh = pxH/2;
    let d = '';
    if(['rect','din_l','din_p','sq'].includes(state.shape)) d = `M ${cx-hw},${cy-hh} H ${cx+hw} V ${cy+hh} H ${cx-hw} Z`;
    else if(state.shape === 'circle') d = `M ${cx},${cy} m -${hw},0 a ${hw},${hw} 0 1,0 ${pxW},0 a ${hw},${hw} 0 1,0 -${pxW},0`;
    else if(state.shape === 'hex') {
      const r = hw, pts = [];
      for(let i=0;i<6;i++){ const a = i*Math.PI/3 - Math.PI/6; pts.push([cx+r*Math.cos(a), cy+r*Math.sin(a)]); }
      d = `M ${pts[0][0]},${pts[0][1]} ` + pts.slice(1).map(p=>`L ${p[0]},${p[1]}`).join(' ') + ' Z';
    }
    $('vfHole').setAttribute('d', d); $('vfOutline').setAttribute('d', d);
    $('vfBadge').style.left = cx+'px';
    $('vfBadge').style.top = (cy+hh)+'px';
    $('vfBadge').innerText = `${state.wMm} Ã— ${state.hMm} mm`;
    state.bbox = { sw: map.containerPointToLatLng([cx-hw, cy+hh]), ne: map.containerPointToLatLng([cx+hw, cy-hh]) };
  }
  window.onresize = updateVf; map.on('move zoom', updateVf); setTimeout(updateVf,500);

  // --- GENERATION PIPELINE ---
  $('btnGen').onclick = async () => {
    msg('Fetching Elevation Data...');
    const {sw, ne} = state.bbox;
    await fetchTerrain(sw, ne);
    if(!state.terrainData) {
      idle();
      alert('Elevation data unavailable. Try a smaller area or try again.');
      return;
    }
    renderSVG();
    idle();
    $('modal').classList.add('open');
  };

  async function fetchTerrain(sw, ne) {
    try {
      const base = 120;
      const scaled = Math.round(base * Math.min(2, Math.max(0.6, state.contour.detail)));
      const rows = Math.max(80, Math.min(200, scaled));
      const cols = rows;
      const locs=[];
      const dLat = (ne.lat-sw.lat)/(rows-1), dLon = (ne.lng-sw.lng)/(cols-1);
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) locs.push({latitude:sw.lat+r*dLat, longitude:sw.lng+c*dLon});
      const res = await fetch('https://api.open-elevation.com/api/v1/lookup', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({locations:locs})});
      const j = await res.json();
      let h = j.results.map(x=>x.elevation);
      // Smooth based on detail: higher detail keeps more variation.
      const smoothPasses = Math.round(6 - (state.contour.detail * 2));
      for(let i=0; i<Math.max(2, smoothPasses); i++) h = smoothPass(h, rows, cols);
      let min=Infinity, max=-Infinity; h.forEach(v => { if(v<min) min=v; if(v>max) max=v; });
      state.terrainData = { rows, cols, h: h.map(z=>z-min), min, max, delta: max-min };
    } catch(e) { state.terrainData = null; }
  }

  function smoothPass(data, rows, cols) {
    const out = new Float32Array(data.length);
    for(let r=0; r<rows; r++) for(let c=0; c<cols; c++) {
      let sum=0, wSum=0;
      for(let rr=r-1; rr<=r+1; rr++) for(let cc=c-1; cc<=c+1; cc++) {
        if(rr>=0 && rr<rows && cc>=0 && cc<cols) {
          const w = (rr===r && cc===c) ? 8 : 1; sum+=data[rr*cols+cc]*w; wSum+=w;
        }
      }
      out[r*cols+c] = sum/wSum;
    }
    return out;
  }

  function renderSVG() {
    const {wMm, hMm} = state;
    let svg = `<svg id="prevSvg" width="${wMm}mm" height="${hMm}mm" viewBox="0 0 ${wMm} ${hMm}" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">`;
    svg += `<rect width="100%" height="100%" fill="${state.theme.background}"/>`;
    svg += `<rect x="0.5" y="0.5" width="${wMm - 1}" height="${hMm - 1}" fill="none" stroke="rgba(36,48,65,0.6)" stroke-width="0.5" />`;

    state.contourSegments = [];
    if(state.terrainData && state.terrainData.delta > 0) {
      const levels = getContourLevels();
      svg += `<g id="contours" stroke="${state.contour.color}" stroke-width="${state.contour.width}" fill="none" stroke-linecap="round" stroke-linejoin="round">`;
      levels.forEach(level => {
        const segments = getContourSegments(level, wMm, hMm);
        if(segments.length) {
          state.contourSegments.push(...segments);
          const path = segments.map(seg => `M ${seg[0][0].toFixed(1)} ${seg[0][1].toFixed(1)} L ${seg[1][0].toFixed(1)} ${seg[1][1].toFixed(1)}`).join(' ');
          svg += `<path d="${path}" />`;
        }
      });
      svg += `</g>`;
    } else {
      const cx = wMm / 2;
      const cy = hMm / 2;
      svg += `<text x="${cx}" y="${cy}" text-anchor="middle" font-family="SF Pro Text, Segoe UI, Roboto, sans-serif" font-size="6" fill="#9AA3B2">Elevation data missing. Try generating again.</text>`;
    }
    svg += `</svg>`;
    $('previewArea').innerHTML = svg;
  }

  $('btnDXF').onclick = () => {
    let dxf = "0\nSECTION\n2\nHEADER\n0\nENDSEC\n0\nSECTION\n2\nENTITIES\n";
    const writeSeg = (l, pts, aci) => {
      dxf += `0\nLWPOLYLINE\n8\n${l}\n62\n${aci}\n90\n${pts.length}\n70\n0\n`;
      pts.forEach(p => dxf += `10\n${p[0].toFixed(4)}\n20\n${(state.hMm - p[1]).toFixed(4)}\n`);
    };
    if(!state.contourSegments.length) {
      alert('Generate contours first.');
      return;
    }
    state.contourSegments.forEach(seg => writeSeg('CONTOURS', seg, 7));
    writeSeg('FRAME', [[0,0],[state.wMm,0],[state.wMm,state.hMm],[0,state.hMm],[0,0]], 6);
    dxf += "0\nENDSEC\n0\nEOF";
    save(new Blob([dxf], {type:'application/dxf'}), 'Topomapper.dxf');
  };

  $('btnPNG').onclick = () => {
    const e = +$('pngResRange').value, r = state.hMm/state.wMm;
    const w = state.wMm >= state.hMm ? e : Math.round(e/r), h = state.wMm >= state.hMm ? Math.round(e*r) : e;
    const s = new XMLSerializer().serializeToString($('prevSvg'));
    const img = new Image(), cv = document.createElement('canvas'); cv.width = w; cv.height = h;
    img.onload = () => { const ctx = cv.getContext('2d'); ctx.fillStyle=state.theme.background; ctx.fillRect(0,0,w,h); ctx.drawImage(img,0,0,w,h); cv.toBlob(b => save(b, 'Topomapper.png')); };
    img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(s)));
  };

  $('btn3MF').onclick = async () => {
    if(!state.terrainData) {
      alert('Generate contours first.');
      return;
    }
    msg('Generating Assembly...'); await new Promise(r=>setTimeout(r,100));
    const zip = new JSZip(), targetH = +$('targetH').value;
    let zScale = state.terrainData && state.terrainData.delta > 0 ? targetH / state.terrainData.delta : 1;
    const objs = []; let objId = 1;

    // 1. Terrain Mesh (Watertight)
    const res = 140, tm = { v:[], t:[] }, idxMap = new Map();
    const isIn = (x,y) => { if(['rect','din_l','din_p','sq'].includes(state.shape)) return true; const dx=x-state.wMm/2, dy=y-state.hMm/2; return (dx*dx+dy*dy)<=(state.wMm/2)**2; };
    for(let r=0;r<=res;r++) for(let c=0;c<=res;c++) {
      const x=c/res*state.wMm, y=r/res*state.hMm; if(!isIn(x,y)) continue;
      const z=2.0 + (getZInterpolated(c/res, r/res) * zScale);
      idxMap.set(`${r},${c}`, {t: tm.v.push([x,y,z])-1, b: tm.v.push([x,y,0])-1 });
    }
    for(let r=0;r<res;r++) for(let c=0;c<res;c++) {
      const tl=idxMap.get(`${r},${c}`), tr=idxMap.get(`${r},${c+1}`), bl=idxMap.get(`${r+1},${c}`), br=idxMap.get(`${r+1},${c+1}`);
      if(tl&&tr&&bl&&br) {
        tm.t.push([tl.t,bl.t,tr.t],[tr.t,bl.t,br.t]);
        tm.t.push([tl.b,tr.b,bl.b],[tr.b,br.b,bl.b]);
        if(!idxMap.get(`${r-1},${c}`)) tm.t.push([tl.t,tr.t,tl.b],[tl.b,tr.t,tr.b]);
        if(!idxMap.get(`${r+1},${c}`)) tm.t.push([bl.t,bl.b,br.t],[br.t,bl.b,br.b]);
        if(!idxMap.get(`${r},${c-1}`)) tm.t.push([tl.t,tl.b,bl.t],[bl.t,bl.b,tl.t]);
        if(!idxMap.get(`${r},${c+1}`)) tm.t.push([tr.t,br.t,tr.b],[tr.b,br.t,br.b]);
      }
    }
    objs.push({id:objId++, name:'Terrain', mesh:tm});

    let resXml='', buildXml='';
    objs.forEach(o => {
      let vS='', tS=''; o.mesh.v.forEach(v=> vS+=`<vertex x="${v[0].toFixed(3)}" y="${v[1].toFixed(3)}" z="${v[2].toFixed(3)}" />`);
      o.mesh.t.forEach(t=> tS+=`<triangle v1="${t[0]}" v2="${t[1]}" v3="${t[2]}" />`);
      resXml += `<object id="${o.id}" name="${o.name}" type="model"><mesh><vertices>${vS}</vertices><triangles>${tS}</triangles></mesh></object>`;
      buildXml += `<item objectid="${o.id}" />`;
    });
    const xml = `<?xml version="1.0" encoding="UTF-8"?><model unit="millimeter" xml:lang="en" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02"><resources>${resXml}</resources><build>${buildXml}</build></model>`;
    zip.file("3D/3dmodel.model", xml);
    zip.file("[Content_Types].xml", `<?xml version="1.0" encoding="UTF-8"?><Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types"><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/><Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml"/></Types>`);
    zip.folder("_rels").file(".rels", `<?xml version="1.0" encoding="UTF-8"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rel1" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" Target="3D/3dmodel.model"/></Relationships>`);
    save(await zip.generateAsync({type:"blob"}), 'Topomapper_Terrain.3mf');
    idle();
  };

  $('btnDownload').onclick = () => {
    const html = '<!doctype html>\n' + document.documentElement.outerHTML;
    save(new Blob([html], { type: 'text/html' }), 'topomapper.html');
  };

  window.closeModal = () => $('modal').classList.remove('open');
  function save(b, n) { const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download=n; a.click(); }
})();
</script>
</body>
</html>
